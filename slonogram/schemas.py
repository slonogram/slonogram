# This file is automatically generated, do not edit it directly
# version: Bot API 6.9 (September 22, 2023)
# generated at: 2023-12-12 08:52:49.512699
from __future__ import annotations
import dataclasses
import typing


@dataclasses.dataclass(slots=True)
class Update:
    """This object represents an incoming update.
    At most one of the optional parameters can be present in any given update.

    More info: https://core.telegram.org/bots/api#update"""

    update_id: int
    "The update's unique identifier. Update identifiers start from a certain positive number and increase sequentially. This ID becomes especially handy if you're using webhooks, since it allows you to ignore repeated updates or to restore the correct update sequence, should they get out of order. If there are no new updates for at least a week, then identifier of the next update will be chosen randomly instead of sequentially."
    message: Message | None = None
    "Optional. New incoming message of any kind - text, photo, sticker, etc."
    edited_message: Message | None = None
    "Optional. New version of a message that is known to the bot and was edited"
    channel_post: Message | None = None
    "Optional. New incoming channel post of any kind - text, photo, sticker, etc."
    edited_channel_post: Message | None = None
    "Optional. New version of a channel post that is known to the bot and was edited"
    inline_query: InlineQuery | None = None
    "Optional. New incoming inline query"
    chosen_inline_result: ChosenInlineResult | None = None
    "Optional. The result of an inline query that was chosen by a user and sent to their chat partner. Please see our documentation on the feedback collecting for details on how to enable these updates for your bot."
    callback_query: CallbackQuery | None = None
    "Optional. New incoming callback query"
    shipping_query: ShippingQuery | None = None
    "Optional. New incoming shipping query. Only for invoices with flexible price"
    pre_checkout_query: PreCheckoutQuery | None = None
    "Optional. New incoming pre-checkout query. Contains full information about checkout"
    poll: Poll | None = None
    "Optional. New poll state. Bots receive only updates about stopped polls and polls, which are sent by the bot"
    poll_answer: PollAnswer | None = None
    "Optional. A user changed their answer in a non-anonymous poll. Bots receive new votes only in polls that were sent by the bot itself."
    my_chat_member: ChatMemberUpdated | None = None
    "Optional. The bot's chat member status was updated in a chat. For private chats, this update is received only when the bot is blocked or unblocked by the user."
    chat_member: ChatMemberUpdated | None = None
    'Optional. A chat member\'s status was updated in a chat. The bot must be an administrator in the chat and must explicitly specify "chat_member" in the list of allowed_updates to receive these updates.'
    chat_join_request: ChatJoinRequest | None = None
    "Optional. A request to join the chat has been sent. The bot must have the can_invite_users administrator right in the chat to receive these updates."

    def copy_with(
        self,
        update_id: int | None = None,
        message: Message | None = None,
        edited_message: Message | None = None,
        channel_post: Message | None = None,
        edited_channel_post: Message | None = None,
        inline_query: InlineQuery | None = None,
        chosen_inline_result: ChosenInlineResult | None = None,
        callback_query: CallbackQuery | None = None,
        shipping_query: ShippingQuery | None = None,
        pre_checkout_query: PreCheckoutQuery | None = None,
        poll: Poll | None = None,
        poll_answer: PollAnswer | None = None,
        my_chat_member: ChatMemberUpdated | None = None,
        chat_member: ChatMemberUpdated | None = None,
        chat_join_request: ChatJoinRequest | None = None,
    ) -> Update:
        return Update(
            update_id=self.update_id if update_id is None else update_id,
            message=self.message if message is None else message,
            edited_message=self.edited_message
            if edited_message is None
            else edited_message,
            channel_post=self.channel_post if channel_post is None else channel_post,
            edited_channel_post=self.edited_channel_post
            if edited_channel_post is None
            else edited_channel_post,
            inline_query=self.inline_query if inline_query is None else inline_query,
            chosen_inline_result=self.chosen_inline_result
            if chosen_inline_result is None
            else chosen_inline_result,
            callback_query=self.callback_query
            if callback_query is None
            else callback_query,
            shipping_query=self.shipping_query
            if shipping_query is None
            else shipping_query,
            pre_checkout_query=self.pre_checkout_query
            if pre_checkout_query is None
            else pre_checkout_query,
            poll=self.poll if poll is None else poll,
            poll_answer=self.poll_answer if poll_answer is None else poll_answer,
            my_chat_member=self.my_chat_member
            if my_chat_member is None
            else my_chat_member,
            chat_member=self.chat_member if chat_member is None else chat_member,
            chat_join_request=self.chat_join_request
            if chat_join_request is None
            else chat_join_request,
        )


@dataclasses.dataclass(slots=True)
class WebhookInfo:
    """Describes the current status of a webhook.

    More info: https://core.telegram.org/bots/api#webhookinfo"""

    url: str
    "Webhook URL, may be empty if webhook is not set up"
    has_custom_certificate: bool
    "True, if a custom certificate was provided for webhook certificate checks"
    pending_update_count: int
    "Number of updates awaiting delivery"
    ip_address: str | None = None
    "Optional. Currently used webhook IP address"
    last_error_date: int | None = None
    "Optional. Unix time for the most recent error that happened when trying to deliver an update via webhook"
    last_error_message: str | None = None
    "Optional. Error message in human-readable format for the most recent error that happened when trying to deliver an update via webhook"
    last_synchronization_error_date: int | None = None
    "Optional. Unix time of the most recent error that happened when trying to synchronize available updates with Telegram datacenters"
    max_connections: int | None = None
    "Optional. The maximum allowed number of simultaneous HTTPS connections to the webhook for update delivery"
    allowed_updates: list[str] | None = None
    "Optional. A list of update types the bot is subscribed to. Defaults to all update types except chat_member"

    def copy_with(
        self,
        url: str | None = None,
        has_custom_certificate: bool | None = None,
        pending_update_count: int | None = None,
        ip_address: str | None = None,
        last_error_date: int | None = None,
        last_error_message: str | None = None,
        last_synchronization_error_date: int | None = None,
        max_connections: int | None = None,
        allowed_updates: list[str] | None = None,
    ) -> WebhookInfo:
        return WebhookInfo(
            url=self.url if url is None else url,
            has_custom_certificate=self.has_custom_certificate
            if has_custom_certificate is None
            else has_custom_certificate,
            pending_update_count=self.pending_update_count
            if pending_update_count is None
            else pending_update_count,
            ip_address=self.ip_address if ip_address is None else ip_address,
            last_error_date=self.last_error_date
            if last_error_date is None
            else last_error_date,
            last_error_message=self.last_error_message
            if last_error_message is None
            else last_error_message,
            last_synchronization_error_date=self.last_synchronization_error_date
            if last_synchronization_error_date is None
            else last_synchronization_error_date,
            max_connections=self.max_connections
            if max_connections is None
            else max_connections,
            allowed_updates=self.allowed_updates
            if allowed_updates is None
            else allowed_updates,
        )


@dataclasses.dataclass(slots=True)
class User:
    """This object represents a Telegram user or bot.

    More info: https://core.telegram.org/bots/api#user"""

    id: int
    "Unique identifier for this user or bot. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier."
    is_bot: bool
    "True, if this user is a bot"
    first_name: str
    "User's or bot's first name"
    last_name: str | None = None
    "Optional. User's or bot's last name"
    username: str | None = None
    "Optional. User's or bot's username"
    language_code: str | None = None
    "Optional. IETF language tag of the user's language"
    is_premium: bool | None = None
    "Optional. True, if this user is a Telegram Premium user"
    added_to_attachment_menu: bool | None = None
    "Optional. True, if this user added the bot to the attachment menu"
    can_join_groups: bool | None = None
    "Optional. True, if the bot can be invited to groups. Returned only in getMe."
    can_read_all_group_messages: bool | None = None
    "Optional. True, if privacy mode is disabled for the bot. Returned only in getMe."
    supports_inline_queries: bool | None = None
    "Optional. True, if the bot supports inline queries. Returned only in getMe."

    def copy_with(
        self,
        id: int | None = None,
        is_bot: bool | None = None,
        first_name: str | None = None,
        last_name: str | None = None,
        username: str | None = None,
        language_code: str | None = None,
        is_premium: bool | None = None,
        added_to_attachment_menu: bool | None = None,
        can_join_groups: bool | None = None,
        can_read_all_group_messages: bool | None = None,
        supports_inline_queries: bool | None = None,
    ) -> User:
        return User(
            id=self.id if id is None else id,
            is_bot=self.is_bot if is_bot is None else is_bot,
            first_name=self.first_name if first_name is None else first_name,
            last_name=self.last_name if last_name is None else last_name,
            username=self.username if username is None else username,
            language_code=self.language_code
            if language_code is None
            else language_code,
            is_premium=self.is_premium if is_premium is None else is_premium,
            added_to_attachment_menu=self.added_to_attachment_menu
            if added_to_attachment_menu is None
            else added_to_attachment_menu,
            can_join_groups=self.can_join_groups
            if can_join_groups is None
            else can_join_groups,
            can_read_all_group_messages=self.can_read_all_group_messages
            if can_read_all_group_messages is None
            else can_read_all_group_messages,
            supports_inline_queries=self.supports_inline_queries
            if supports_inline_queries is None
            else supports_inline_queries,
        )


@dataclasses.dataclass(slots=True)
class Chat:
    """This object represents a chat.

    More info: https://core.telegram.org/bots/api#chat"""

    id: int
    "Unique identifier for this chat. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."
    type: str
    'Type of chat, can be either "private", "group", "supergroup" or "channel"'
    title: str | None = None
    "Optional. Title, for supergroups, channels and group chats"
    username: str | None = None
    "Optional. Username, for private chats, supergroups and channels if available"
    first_name: str | None = None
    "Optional. First name of the other party in a private chat"
    last_name: str | None = None
    "Optional. Last name of the other party in a private chat"
    is_forum: bool | None = None
    "Optional. True, if the supergroup chat is a forum (has topics enabled)"
    photo: ChatPhoto | None = None
    "Optional. Chat photo. Returned only in getChat."
    active_usernames: list[str] | None = None
    "Optional. If non-empty, the list of all active chat usernames; for private chats, supergroups and channels. Returned only in getChat."
    emoji_status_custom_emoji_id: str | None = None
    "Optional. Custom emoji identifier of emoji status of the other party in a private chat. Returned only in getChat."
    emoji_status_expiration_date: int | None = None
    "Optional. Expiration date of the emoji status of the other party in a private chat in Unix time, if any. Returned only in getChat."
    bio: str | None = None
    "Optional. Bio of the other party in a private chat. Returned only in getChat."
    has_private_forwards: bool | None = None
    "Optional. True, if privacy settings of the other party in the private chat allows to use tg://user?id=<user_id> links only in chats with the user. Returned only in getChat."
    has_restricted_voice_and_video_messages: bool | None = None
    "Optional. True, if the privacy settings of the other party restrict sending voice and video note messages in the private chat. Returned only in getChat."
    join_to_send_messages: bool | None = None
    "Optional. True, if users need to join the supergroup before they can send messages. Returned only in getChat."
    join_by_request: bool | None = None
    "Optional. True, if all users directly joining the supergroup need to be approved by supergroup administrators. Returned only in getChat."
    description: str | None = None
    "Optional. Description, for groups, supergroups and channel chats. Returned only in getChat."
    invite_link: str | None = None
    "Optional. Primary invite link, for groups, supergroups and channel chats. Returned only in getChat."
    pinned_message: Message | None = None
    "Optional. The most recent pinned message (by sending date). Returned only in getChat."
    permissions: ChatPermissions | None = None
    "Optional. Default chat member permissions, for groups and supergroups. Returned only in getChat."
    slow_mode_delay: int | None = None
    "Optional. For supergroups, the minimum allowed delay between consecutive messages sent by each unpriviledged user; in seconds. Returned only in getChat."
    message_auto_delete_time: int | None = None
    "Optional. The time after which all messages sent to the chat will be automatically deleted; in seconds. Returned only in getChat."
    has_aggressive_anti_spam_enabled: bool | None = None
    "Optional. True, if aggressive anti-spam checks are enabled in the supergroup. The field is only available to chat administrators. Returned only in getChat."
    has_hidden_members: bool | None = None
    "Optional. True, if non-administrators can only get the list of bots and administrators in the chat. Returned only in getChat."
    has_protected_content: bool | None = None
    "Optional. True, if messages from the chat can't be forwarded to other chats. Returned only in getChat."
    sticker_set_name: str | None = None
    "Optional. For supergroups, name of group sticker set. Returned only in getChat."
    can_set_sticker_set: bool | None = None
    "Optional. True, if the bot can change the group sticker set. Returned only in getChat."
    linked_chat_id: int | None = None
    "Optional. Unique identifier for the linked chat, i.e. the discussion group identifier for a channel and vice versa; for supergroups and channel chats. This identifier may be greater than 32 bits and some programming languages may have difficulty/silent defects in interpreting it. But it is smaller than 52 bits, so a signed 64 bit integer or double-precision float type are safe for storing this identifier. Returned only in getChat."
    location: ChatLocation | None = None
    "Optional. For supergroups, the location to which the supergroup is connected. Returned only in getChat."

    def copy_with(
        self,
        id: int | None = None,
        type: str | None = None,
        title: str | None = None,
        username: str | None = None,
        first_name: str | None = None,
        last_name: str | None = None,
        is_forum: bool | None = None,
        photo: ChatPhoto | None = None,
        active_usernames: list[str] | None = None,
        emoji_status_custom_emoji_id: str | None = None,
        emoji_status_expiration_date: int | None = None,
        bio: str | None = None,
        has_private_forwards: bool | None = None,
        has_restricted_voice_and_video_messages: bool | None = None,
        join_to_send_messages: bool | None = None,
        join_by_request: bool | None = None,
        description: str | None = None,
        invite_link: str | None = None,
        pinned_message: Message | None = None,
        permissions: ChatPermissions | None = None,
        slow_mode_delay: int | None = None,
        message_auto_delete_time: int | None = None,
        has_aggressive_anti_spam_enabled: bool | None = None,
        has_hidden_members: bool | None = None,
        has_protected_content: bool | None = None,
        sticker_set_name: str | None = None,
        can_set_sticker_set: bool | None = None,
        linked_chat_id: int | None = None,
        location: ChatLocation | None = None,
    ) -> Chat:
        return Chat(
            id=self.id if id is None else id,
            type=self.type if type is None else type,
            title=self.title if title is None else title,
            username=self.username if username is None else username,
            first_name=self.first_name if first_name is None else first_name,
            last_name=self.last_name if last_name is None else last_name,
            is_forum=self.is_forum if is_forum is None else is_forum,
            photo=self.photo if photo is None else photo,
            active_usernames=self.active_usernames
            if active_usernames is None
            else active_usernames,
            emoji_status_custom_emoji_id=self.emoji_status_custom_emoji_id
            if emoji_status_custom_emoji_id is None
            else emoji_status_custom_emoji_id,
            emoji_status_expiration_date=self.emoji_status_expiration_date
            if emoji_status_expiration_date is None
            else emoji_status_expiration_date,
            bio=self.bio if bio is None else bio,
            has_private_forwards=self.has_private_forwards
            if has_private_forwards is None
            else has_private_forwards,
            has_restricted_voice_and_video_messages=self.has_restricted_voice_and_video_messages
            if has_restricted_voice_and_video_messages is None
            else has_restricted_voice_and_video_messages,
            join_to_send_messages=self.join_to_send_messages
            if join_to_send_messages is None
            else join_to_send_messages,
            join_by_request=self.join_by_request
            if join_by_request is None
            else join_by_request,
            description=self.description if description is None else description,
            invite_link=self.invite_link if invite_link is None else invite_link,
            pinned_message=self.pinned_message
            if pinned_message is None
            else pinned_message,
            permissions=self.permissions if permissions is None else permissions,
            slow_mode_delay=self.slow_mode_delay
            if slow_mode_delay is None
            else slow_mode_delay,
            message_auto_delete_time=self.message_auto_delete_time
            if message_auto_delete_time is None
            else message_auto_delete_time,
            has_aggressive_anti_spam_enabled=self.has_aggressive_anti_spam_enabled
            if has_aggressive_anti_spam_enabled is None
            else has_aggressive_anti_spam_enabled,
            has_hidden_members=self.has_hidden_members
            if has_hidden_members is None
            else has_hidden_members,
            has_protected_content=self.has_protected_content
            if has_protected_content is None
            else has_protected_content,
            sticker_set_name=self.sticker_set_name
            if sticker_set_name is None
            else sticker_set_name,
            can_set_sticker_set=self.can_set_sticker_set
            if can_set_sticker_set is None
            else can_set_sticker_set,
            linked_chat_id=self.linked_chat_id
            if linked_chat_id is None
            else linked_chat_id,
            location=self.location if location is None else location,
        )


@dataclasses.dataclass(slots=True)
class Message:
    """This object represents a message.

    More info: https://core.telegram.org/bots/api#message"""

    message_id: int
    "Unique message identifier inside this chat"
    date: int
    "Date the message was sent in Unix time"
    chat: Chat
    "Conversation the message belongs to"
    message_thread_id: int | None = None
    "Optional. Unique identifier of a message thread to which the message belongs; for supergroups only"
    from_: User | None = None
    "Optional. Sender of the message; empty for messages sent to channels. For backward compatibility, the field contains a fake sender user in non-channel chats, if the message was sent on behalf of a chat."
    sender_chat: Chat | None = None
    "Optional. Sender of the message, sent on behalf of a chat. For example, the channel itself for channel posts, the supergroup itself for messages from anonymous group administrators, the linked channel for messages automatically forwarded to the discussion group. For backward compatibility, the field from contains a fake sender user in non-channel chats, if the message was sent on behalf of a chat."
    forward_from: User | None = None
    "Optional. For forwarded messages, sender of the original message"
    forward_from_chat: Chat | None = None
    "Optional. For messages forwarded from channels or from anonymous administrators, information about the original sender chat"
    forward_from_message_id: int | None = None
    "Optional. For messages forwarded from channels, identifier of the original message in the channel"
    forward_signature: str | None = None
    "Optional. For forwarded messages that were originally sent in channels or by an anonymous chat administrator, signature of the message sender if present"
    forward_sender_name: str | None = None
    "Optional. Sender's name for messages forwarded from users who disallow adding a link to their account in forwarded messages"
    forward_date: int | None = None
    "Optional. For forwarded messages, date the original message was sent in Unix time"
    is_topic_message: bool | None = None
    "Optional. True, if the message is sent to a forum topic"
    is_automatic_forward: bool | None = None
    "Optional. True, if the message is a channel post that was automatically forwarded to the connected discussion group"
    reply_to_message: Message | None = None
    "Optional. For replies, the original message. Note that the Message object in this field will not contain further reply_to_message fields even if it itself is a reply."
    via_bot: User | None = None
    "Optional. Bot through which the message was sent"
    edit_date: int | None = None
    "Optional. Date the message was last edited in Unix time"
    has_protected_content: bool | None = None
    "Optional. True, if the message can't be forwarded"
    media_group_id: str | None = None
    "Optional. The unique identifier of a media message group this message belongs to"
    author_signature: str | None = None
    "Optional. Signature of the post author for messages in channels, or the custom title of an anonymous group administrator"
    text: str | None = None
    "Optional. For text messages, the actual UTF-8 text of the message"
    entities: list[MessageEntity] | None = None
    "Optional. For text messages, special entities like usernames, URLs, bot commands, etc. that appear in the text"
    animation: Animation | None = None
    "Optional. Message is an animation, information about the animation. For backward compatibility, when this field is set, the document field will also be set"
    audio: Audio | None = None
    "Optional. Message is an audio file, information about the file"
    document: Document | None = None
    "Optional. Message is a general file, information about the file"
    photo: list[PhotoSize] | None = None
    "Optional. Message is a photo, available sizes of the photo"
    sticker: Sticker | None = None
    "Optional. Message is a sticker, information about the sticker"
    story: Story | None = None
    "Optional. Message is a forwarded story"
    video: Video | None = None
    "Optional. Message is a video, information about the video"
    video_note: VideoNote | None = None
    "Optional. Message is a video note, information about the video message"
    voice: Voice | None = None
    "Optional. Message is a voice message, information about the file"
    caption: str | None = None
    "Optional. Caption for the animation, audio, document, photo, video or voice"
    caption_entities: list[MessageEntity] | None = None
    "Optional. For messages with a caption, special entities like usernames, URLs, bot commands, etc. that appear in the caption"
    has_media_spoiler: bool | None = None
    "Optional. True, if the message media is covered by a spoiler animation"
    contact: Contact | None = None
    "Optional. Message is a shared contact, information about the contact"
    dice: Dice | None = None
    "Optional. Message is a dice with random value"
    game: Game | None = None
    "Optional. Message is a game, information about the game. More about games: https://core.telegram.org/bots/api#games"
    poll: Poll | None = None
    "Optional. Message is a native poll, information about the poll"
    venue: Venue | None = None
    "Optional. Message is a venue, information about the venue. For backward compatibility, when this field is set, the location field will also be set"
    location: Location | None = None
    "Optional. Message is a shared location, information about the location"
    new_chat_members: list[User] | None = None
    "Optional. New members that were added to the group or supergroup and information about them (the bot itself may be one of these members)"
    left_chat_member: User | None = None
    "Optional. A member was removed from the group, information about them (this member may be the bot itself)"
    new_chat_title: str | None = None
    "Optional. A chat title was changed to this value"
    new_chat_photo: list[PhotoSize] | None = None
    "Optional. A chat photo was change to this value"
    delete_chat_photo: bool | None = None
    "Optional. Service message: the chat photo was deleted"
    group_chat_created: bool | None = None
    "Optional. Service message: the group has been created"
    supergroup_chat_created: bool | None = None
    "Optional. Service message: the supergroup has been created. This field can't be received in a message coming through updates, because bot can't be a member of a supergroup when it is created. It can only be found in reply_to_message if someone replies to a very first message in a directly created supergroup."
    channel_chat_created: bool | None = None
    "Optional. Service message: the channel has been created. This field can't be received in a message coming through updates, because bot can't be a member of a channel when it is created. It can only be found in reply_to_message if someone replies to a very first message in a channel."
    message_auto_delete_timer_changed: MessageAutoDeleteTimerChanged | None = None
    "Optional. Service message: auto-delete timer settings changed in the chat"
    migrate_to_chat_id: int | None = None
    "Optional. The group has been migrated to a supergroup with the specified identifier. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."
    migrate_from_chat_id: int | None = None
    "Optional. The supergroup has been migrated from a group with the specified identifier. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."
    pinned_message: Message | None = None
    "Optional. Specified message was pinned. Note that the Message object in this field will not contain further reply_to_message fields even if it is itself a reply."
    invoice: Invoice | None = None
    "Optional. Message is an invoice for a payment, information about the invoice. More about payments: https://core.telegram.org/bots/api#payments"
    successful_payment: SuccessfulPayment | None = None
    "Optional. Message is a service message about a successful payment, information about the payment. More about payments: https://core.telegram.org/bots/api#payments"
    user_shared: UserShared | None = None
    "Optional. Service message: a user was shared with the bot"
    chat_shared: ChatShared | None = None
    "Optional. Service message: a chat was shared with the bot"
    connected_website: str | None = None
    "Optional. The domain name of the website on which the user has logged in. More about Telegram Login: https://core.telegram.org/widgets/login"
    write_access_allowed: WriteAccessAllowed | None = None
    "Optional. Service message: the user allowed the bot to write messages after adding it to the attachment or side menu, launching a Web App from a link, or accepting an explicit request from a Web App sent by the method requestWriteAccess"
    passport_data: PassportData | None = None
    "Optional. Telegram Passport data"
    proximity_alert_triggered: ProximityAlertTriggered | None = None
    "Optional. Service message. A user in the chat triggered another user's proximity alert while sharing Live Location."
    forum_topic_created: ForumTopicCreated | None = None
    "Optional. Service message: forum topic created"
    forum_topic_edited: ForumTopicEdited | None = None
    "Optional. Service message: forum topic edited"
    forum_topic_closed: ForumTopicClosed | None = None
    "Optional. Service message: forum topic closed"
    forum_topic_reopened: ForumTopicReopened | None = None
    "Optional. Service message: forum topic reopened"
    general_forum_topic_hidden: GeneralForumTopicHidden | None = None
    "Optional. Service message: the 'General' forum topic hidden"
    general_forum_topic_unhidden: GeneralForumTopicUnhidden | None = None
    "Optional. Service message: the 'General' forum topic unhidden"
    video_chat_scheduled: VideoChatScheduled | None = None
    "Optional. Service message: video chat scheduled"
    video_chat_started: VideoChatStarted | None = None
    "Optional. Service message: video chat started"
    video_chat_ended: VideoChatEnded | None = None
    "Optional. Service message: video chat ended"
    video_chat_participants_invited: VideoChatParticipantsInvited | None = None
    "Optional. Service message: new participants invited to a video chat"
    web_app_data: WebAppData | None = None
    "Optional. Service message: data sent by a Web App"
    reply_markup: InlineKeyboardMarkup | None = None
    "Optional. Inline keyboard attached to the message. login_url buttons are represented as ordinary url buttons."

    def copy_with(
        self,
        message_id: int | None = None,
        message_thread_id: int | None = None,
        from_: User | None = None,
        sender_chat: Chat | None = None,
        date: int | None = None,
        chat: Chat | None = None,
        forward_from: User | None = None,
        forward_from_chat: Chat | None = None,
        forward_from_message_id: int | None = None,
        forward_signature: str | None = None,
        forward_sender_name: str | None = None,
        forward_date: int | None = None,
        is_topic_message: bool | None = None,
        is_automatic_forward: bool | None = None,
        reply_to_message: Message | None = None,
        via_bot: User | None = None,
        edit_date: int | None = None,
        has_protected_content: bool | None = None,
        media_group_id: str | None = None,
        author_signature: str | None = None,
        text: str | None = None,
        entities: list[MessageEntity] | None = None,
        animation: Animation | None = None,
        audio: Audio | None = None,
        document: Document | None = None,
        photo: list[PhotoSize] | None = None,
        sticker: Sticker | None = None,
        story: Story | None = None,
        video: Video | None = None,
        video_note: VideoNote | None = None,
        voice: Voice | None = None,
        caption: str | None = None,
        caption_entities: list[MessageEntity] | None = None,
        has_media_spoiler: bool | None = None,
        contact: Contact | None = None,
        dice: Dice | None = None,
        game: Game | None = None,
        poll: Poll | None = None,
        venue: Venue | None = None,
        location: Location | None = None,
        new_chat_members: list[User] | None = None,
        left_chat_member: User | None = None,
        new_chat_title: str | None = None,
        new_chat_photo: list[PhotoSize] | None = None,
        delete_chat_photo: bool | None = None,
        group_chat_created: bool | None = None,
        supergroup_chat_created: bool | None = None,
        channel_chat_created: bool | None = None,
        message_auto_delete_timer_changed: MessageAutoDeleteTimerChanged | None = None,
        migrate_to_chat_id: int | None = None,
        migrate_from_chat_id: int | None = None,
        pinned_message: Message | None = None,
        invoice: Invoice | None = None,
        successful_payment: SuccessfulPayment | None = None,
        user_shared: UserShared | None = None,
        chat_shared: ChatShared | None = None,
        connected_website: str | None = None,
        write_access_allowed: WriteAccessAllowed | None = None,
        passport_data: PassportData | None = None,
        proximity_alert_triggered: ProximityAlertTriggered | None = None,
        forum_topic_created: ForumTopicCreated | None = None,
        forum_topic_edited: ForumTopicEdited | None = None,
        forum_topic_closed: ForumTopicClosed | None = None,
        forum_topic_reopened: ForumTopicReopened | None = None,
        general_forum_topic_hidden: GeneralForumTopicHidden | None = None,
        general_forum_topic_unhidden: GeneralForumTopicUnhidden | None = None,
        video_chat_scheduled: VideoChatScheduled | None = None,
        video_chat_started: VideoChatStarted | None = None,
        video_chat_ended: VideoChatEnded | None = None,
        video_chat_participants_invited: VideoChatParticipantsInvited | None = None,
        web_app_data: WebAppData | None = None,
        reply_markup: InlineKeyboardMarkup | None = None,
    ) -> Message:
        return Message(
            message_id=self.message_id if message_id is None else message_id,
            message_thread_id=self.message_thread_id
            if message_thread_id is None
            else message_thread_id,
            from_=self.from_ if from_ is None else from_,
            sender_chat=self.sender_chat if sender_chat is None else sender_chat,
            date=self.date if date is None else date,
            chat=self.chat if chat is None else chat,
            forward_from=self.forward_from if forward_from is None else forward_from,
            forward_from_chat=self.forward_from_chat
            if forward_from_chat is None
            else forward_from_chat,
            forward_from_message_id=self.forward_from_message_id
            if forward_from_message_id is None
            else forward_from_message_id,
            forward_signature=self.forward_signature
            if forward_signature is None
            else forward_signature,
            forward_sender_name=self.forward_sender_name
            if forward_sender_name is None
            else forward_sender_name,
            forward_date=self.forward_date if forward_date is None else forward_date,
            is_topic_message=self.is_topic_message
            if is_topic_message is None
            else is_topic_message,
            is_automatic_forward=self.is_automatic_forward
            if is_automatic_forward is None
            else is_automatic_forward,
            reply_to_message=self.reply_to_message
            if reply_to_message is None
            else reply_to_message,
            via_bot=self.via_bot if via_bot is None else via_bot,
            edit_date=self.edit_date if edit_date is None else edit_date,
            has_protected_content=self.has_protected_content
            if has_protected_content is None
            else has_protected_content,
            media_group_id=self.media_group_id
            if media_group_id is None
            else media_group_id,
            author_signature=self.author_signature
            if author_signature is None
            else author_signature,
            text=self.text if text is None else text,
            entities=self.entities if entities is None else entities,
            animation=self.animation if animation is None else animation,
            audio=self.audio if audio is None else audio,
            document=self.document if document is None else document,
            photo=self.photo if photo is None else photo,
            sticker=self.sticker if sticker is None else sticker,
            story=self.story if story is None else story,
            video=self.video if video is None else video,
            video_note=self.video_note if video_note is None else video_note,
            voice=self.voice if voice is None else voice,
            caption=self.caption if caption is None else caption,
            caption_entities=self.caption_entities
            if caption_entities is None
            else caption_entities,
            has_media_spoiler=self.has_media_spoiler
            if has_media_spoiler is None
            else has_media_spoiler,
            contact=self.contact if contact is None else contact,
            dice=self.dice if dice is None else dice,
            game=self.game if game is None else game,
            poll=self.poll if poll is None else poll,
            venue=self.venue if venue is None else venue,
            location=self.location if location is None else location,
            new_chat_members=self.new_chat_members
            if new_chat_members is None
            else new_chat_members,
            left_chat_member=self.left_chat_member
            if left_chat_member is None
            else left_chat_member,
            new_chat_title=self.new_chat_title
            if new_chat_title is None
            else new_chat_title,
            new_chat_photo=self.new_chat_photo
            if new_chat_photo is None
            else new_chat_photo,
            delete_chat_photo=self.delete_chat_photo
            if delete_chat_photo is None
            else delete_chat_photo,
            group_chat_created=self.group_chat_created
            if group_chat_created is None
            else group_chat_created,
            supergroup_chat_created=self.supergroup_chat_created
            if supergroup_chat_created is None
            else supergroup_chat_created,
            channel_chat_created=self.channel_chat_created
            if channel_chat_created is None
            else channel_chat_created,
            message_auto_delete_timer_changed=self.message_auto_delete_timer_changed
            if message_auto_delete_timer_changed is None
            else message_auto_delete_timer_changed,
            migrate_to_chat_id=self.migrate_to_chat_id
            if migrate_to_chat_id is None
            else migrate_to_chat_id,
            migrate_from_chat_id=self.migrate_from_chat_id
            if migrate_from_chat_id is None
            else migrate_from_chat_id,
            pinned_message=self.pinned_message
            if pinned_message is None
            else pinned_message,
            invoice=self.invoice if invoice is None else invoice,
            successful_payment=self.successful_payment
            if successful_payment is None
            else successful_payment,
            user_shared=self.user_shared if user_shared is None else user_shared,
            chat_shared=self.chat_shared if chat_shared is None else chat_shared,
            connected_website=self.connected_website
            if connected_website is None
            else connected_website,
            write_access_allowed=self.write_access_allowed
            if write_access_allowed is None
            else write_access_allowed,
            passport_data=self.passport_data
            if passport_data is None
            else passport_data,
            proximity_alert_triggered=self.proximity_alert_triggered
            if proximity_alert_triggered is None
            else proximity_alert_triggered,
            forum_topic_created=self.forum_topic_created
            if forum_topic_created is None
            else forum_topic_created,
            forum_topic_edited=self.forum_topic_edited
            if forum_topic_edited is None
            else forum_topic_edited,
            forum_topic_closed=self.forum_topic_closed
            if forum_topic_closed is None
            else forum_topic_closed,
            forum_topic_reopened=self.forum_topic_reopened
            if forum_topic_reopened is None
            else forum_topic_reopened,
            general_forum_topic_hidden=self.general_forum_topic_hidden
            if general_forum_topic_hidden is None
            else general_forum_topic_hidden,
            general_forum_topic_unhidden=self.general_forum_topic_unhidden
            if general_forum_topic_unhidden is None
            else general_forum_topic_unhidden,
            video_chat_scheduled=self.video_chat_scheduled
            if video_chat_scheduled is None
            else video_chat_scheduled,
            video_chat_started=self.video_chat_started
            if video_chat_started is None
            else video_chat_started,
            video_chat_ended=self.video_chat_ended
            if video_chat_ended is None
            else video_chat_ended,
            video_chat_participants_invited=self.video_chat_participants_invited
            if video_chat_participants_invited is None
            else video_chat_participants_invited,
            web_app_data=self.web_app_data if web_app_data is None else web_app_data,
            reply_markup=self.reply_markup if reply_markup is None else reply_markup,
        )


@dataclasses.dataclass(slots=True)
class MessageId:
    """This object represents a unique message identifier.

    More info: https://core.telegram.org/bots/api#messageid"""

    message_id: int
    "Unique message identifier"

    def copy_with(
        self,
        message_id: int | None = None,
    ) -> MessageId:
        return MessageId(
            message_id=self.message_id if message_id is None else message_id
        )


@dataclasses.dataclass(slots=True)
class MessageEntity:
    """This object represents one special entity in a text message. For example, hashtags, usernames, URLs, etc.

    More info: https://core.telegram.org/bots/api#messageentity"""

    type: str
    'Type of the entity. Currently, can be "mention" (@username), "hashtag" (#hashtag), "cashtag" ($USD), "bot_command" (/start@jobs_bot), "url" (https://telegram.org), "email" (do-not-reply@telegram.org), "phone_number" (+1-212-555-0123), "bold" (bold text), "italic" (italic text), "underline" (underlined text), "strikethrough" (strikethrough text), "spoiler" (spoiler message), "code" (monowidth string), "pre" (monowidth block), "text_link" (for clickable text URLs), "text_mention" (for users without usernames), "custom_emoji" (for inline custom emoji stickers)'
    offset: int
    "Offset in UTF-16 code units to the start of the entity"
    length: int
    "Length of the entity in UTF-16 code units"
    url: str | None = None
    'Optional. For "text_link" only, URL that will be opened after user taps on the text'
    user: User | None = None
    'Optional. For "text_mention" only, the mentioned user'
    language: str | None = None
    'Optional. For "pre" only, the programming language of the entity text'
    custom_emoji_id: str | None = None
    'Optional. For "custom_emoji" only, unique identifier of the custom emoji. Use getCustomEmojiStickers to get full information about the sticker'

    def copy_with(
        self,
        type: str | None = None,
        offset: int | None = None,
        length: int | None = None,
        url: str | None = None,
        user: User | None = None,
        language: str | None = None,
        custom_emoji_id: str | None = None,
    ) -> MessageEntity:
        return MessageEntity(
            type=self.type if type is None else type,
            offset=self.offset if offset is None else offset,
            length=self.length if length is None else length,
            url=self.url if url is None else url,
            user=self.user if user is None else user,
            language=self.language if language is None else language,
            custom_emoji_id=self.custom_emoji_id
            if custom_emoji_id is None
            else custom_emoji_id,
        )


@dataclasses.dataclass(slots=True)
class PhotoSize:
    """This object represents one size of a photo or a file / sticker thumbnail.

    More info: https://core.telegram.org/bots/api#photosize"""

    file_id: str
    "Identifier for this file, which can be used to download or reuse the file"
    file_unique_id: str
    "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."
    width: int
    "Photo width"
    height: int
    "Photo height"
    file_size: int | None = None
    "Optional. File size in bytes"

    def copy_with(
        self,
        file_id: str | None = None,
        file_unique_id: str | None = None,
        width: int | None = None,
        height: int | None = None,
        file_size: int | None = None,
    ) -> PhotoSize:
        return PhotoSize(
            file_id=self.file_id if file_id is None else file_id,
            file_unique_id=self.file_unique_id
            if file_unique_id is None
            else file_unique_id,
            width=self.width if width is None else width,
            height=self.height if height is None else height,
            file_size=self.file_size if file_size is None else file_size,
        )


@dataclasses.dataclass(slots=True)
class Animation:
    """This object represents an animation file (GIF or H.264/MPEG-4 AVC video without sound).

    More info: https://core.telegram.org/bots/api#animation"""

    file_id: str
    "Identifier for this file, which can be used to download or reuse the file"
    file_unique_id: str
    "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."
    width: int
    "Video width as defined by sender"
    height: int
    "Video height as defined by sender"
    duration: int
    "Duration of the video in seconds as defined by sender"
    thumbnail: PhotoSize | None = None
    "Optional. Animation thumbnail as defined by sender"
    file_name: str | None = None
    "Optional. Original animation filename as defined by sender"
    mime_type: str | None = None
    "Optional. MIME type of the file as defined by sender"
    file_size: int | None = None
    "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."

    def copy_with(
        self,
        file_id: str | None = None,
        file_unique_id: str | None = None,
        width: int | None = None,
        height: int | None = None,
        duration: int | None = None,
        thumbnail: PhotoSize | None = None,
        file_name: str | None = None,
        mime_type: str | None = None,
        file_size: int | None = None,
    ) -> Animation:
        return Animation(
            file_id=self.file_id if file_id is None else file_id,
            file_unique_id=self.file_unique_id
            if file_unique_id is None
            else file_unique_id,
            width=self.width if width is None else width,
            height=self.height if height is None else height,
            duration=self.duration if duration is None else duration,
            thumbnail=self.thumbnail if thumbnail is None else thumbnail,
            file_name=self.file_name if file_name is None else file_name,
            mime_type=self.mime_type if mime_type is None else mime_type,
            file_size=self.file_size if file_size is None else file_size,
        )


@dataclasses.dataclass(slots=True)
class Audio:
    """This object represents an audio file to be treated as music by the Telegram clients.

    More info: https://core.telegram.org/bots/api#audio"""

    file_id: str
    "Identifier for this file, which can be used to download or reuse the file"
    file_unique_id: str
    "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."
    duration: int
    "Duration of the audio in seconds as defined by sender"
    performer: str | None = None
    "Optional. Performer of the audio as defined by sender or by audio tags"
    title: str | None = None
    "Optional. Title of the audio as defined by sender or by audio tags"
    file_name: str | None = None
    "Optional. Original filename as defined by sender"
    mime_type: str | None = None
    "Optional. MIME type of the file as defined by sender"
    file_size: int | None = None
    "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."
    thumbnail: PhotoSize | None = None
    "Optional. Thumbnail of the album cover to which the music file belongs"

    def copy_with(
        self,
        file_id: str | None = None,
        file_unique_id: str | None = None,
        duration: int | None = None,
        performer: str | None = None,
        title: str | None = None,
        file_name: str | None = None,
        mime_type: str | None = None,
        file_size: int | None = None,
        thumbnail: PhotoSize | None = None,
    ) -> Audio:
        return Audio(
            file_id=self.file_id if file_id is None else file_id,
            file_unique_id=self.file_unique_id
            if file_unique_id is None
            else file_unique_id,
            duration=self.duration if duration is None else duration,
            performer=self.performer if performer is None else performer,
            title=self.title if title is None else title,
            file_name=self.file_name if file_name is None else file_name,
            mime_type=self.mime_type if mime_type is None else mime_type,
            file_size=self.file_size if file_size is None else file_size,
            thumbnail=self.thumbnail if thumbnail is None else thumbnail,
        )


@dataclasses.dataclass(slots=True)
class Document:
    """This object represents a general file (as opposed to photos, voice messages and audio files).

    More info: https://core.telegram.org/bots/api#document"""

    file_id: str
    "Identifier for this file, which can be used to download or reuse the file"
    file_unique_id: str
    "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."
    thumbnail: PhotoSize | None = None
    "Optional. Document thumbnail as defined by sender"
    file_name: str | None = None
    "Optional. Original filename as defined by sender"
    mime_type: str | None = None
    "Optional. MIME type of the file as defined by sender"
    file_size: int | None = None
    "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."

    def copy_with(
        self,
        file_id: str | None = None,
        file_unique_id: str | None = None,
        thumbnail: PhotoSize | None = None,
        file_name: str | None = None,
        mime_type: str | None = None,
        file_size: int | None = None,
    ) -> Document:
        return Document(
            file_id=self.file_id if file_id is None else file_id,
            file_unique_id=self.file_unique_id
            if file_unique_id is None
            else file_unique_id,
            thumbnail=self.thumbnail if thumbnail is None else thumbnail,
            file_name=self.file_name if file_name is None else file_name,
            mime_type=self.mime_type if mime_type is None else mime_type,
            file_size=self.file_size if file_size is None else file_size,
        )


@dataclasses.dataclass(slots=True)
class Story:
    """This object represents a message about a forwarded story in the chat. Currently holds no information.

    More info: https://core.telegram.org/bots/api#story"""

    pass


@dataclasses.dataclass(slots=True)
class Video:
    """This object represents a video file.

    More info: https://core.telegram.org/bots/api#video"""

    file_id: str
    "Identifier for this file, which can be used to download or reuse the file"
    file_unique_id: str
    "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."
    width: int
    "Video width as defined by sender"
    height: int
    "Video height as defined by sender"
    duration: int
    "Duration of the video in seconds as defined by sender"
    thumbnail: PhotoSize | None = None
    "Optional. Video thumbnail"
    file_name: str | None = None
    "Optional. Original filename as defined by sender"
    mime_type: str | None = None
    "Optional. MIME type of the file as defined by sender"
    file_size: int | None = None
    "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."

    def copy_with(
        self,
        file_id: str | None = None,
        file_unique_id: str | None = None,
        width: int | None = None,
        height: int | None = None,
        duration: int | None = None,
        thumbnail: PhotoSize | None = None,
        file_name: str | None = None,
        mime_type: str | None = None,
        file_size: int | None = None,
    ) -> Video:
        return Video(
            file_id=self.file_id if file_id is None else file_id,
            file_unique_id=self.file_unique_id
            if file_unique_id is None
            else file_unique_id,
            width=self.width if width is None else width,
            height=self.height if height is None else height,
            duration=self.duration if duration is None else duration,
            thumbnail=self.thumbnail if thumbnail is None else thumbnail,
            file_name=self.file_name if file_name is None else file_name,
            mime_type=self.mime_type if mime_type is None else mime_type,
            file_size=self.file_size if file_size is None else file_size,
        )


@dataclasses.dataclass(slots=True)
class VideoNote:
    """This object represents a video message (available in Telegram apps as of v.4.0).

    More info: https://core.telegram.org/bots/api#videonote"""

    file_id: str
    "Identifier for this file, which can be used to download or reuse the file"
    file_unique_id: str
    "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."
    length: int
    "Video width and height (diameter of the video message) as defined by sender"
    duration: int
    "Duration of the video in seconds as defined by sender"
    thumbnail: PhotoSize | None = None
    "Optional. Video thumbnail"
    file_size: int | None = None
    "Optional. File size in bytes"

    def copy_with(
        self,
        file_id: str | None = None,
        file_unique_id: str | None = None,
        length: int | None = None,
        duration: int | None = None,
        thumbnail: PhotoSize | None = None,
        file_size: int | None = None,
    ) -> VideoNote:
        return VideoNote(
            file_id=self.file_id if file_id is None else file_id,
            file_unique_id=self.file_unique_id
            if file_unique_id is None
            else file_unique_id,
            length=self.length if length is None else length,
            duration=self.duration if duration is None else duration,
            thumbnail=self.thumbnail if thumbnail is None else thumbnail,
            file_size=self.file_size if file_size is None else file_size,
        )


@dataclasses.dataclass(slots=True)
class Voice:
    """This object represents a voice note.

    More info: https://core.telegram.org/bots/api#voice"""

    file_id: str
    "Identifier for this file, which can be used to download or reuse the file"
    file_unique_id: str
    "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."
    duration: int
    "Duration of the audio in seconds as defined by sender"
    mime_type: str | None = None
    "Optional. MIME type of the file as defined by sender"
    file_size: int | None = None
    "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."

    def copy_with(
        self,
        file_id: str | None = None,
        file_unique_id: str | None = None,
        duration: int | None = None,
        mime_type: str | None = None,
        file_size: int | None = None,
    ) -> Voice:
        return Voice(
            file_id=self.file_id if file_id is None else file_id,
            file_unique_id=self.file_unique_id
            if file_unique_id is None
            else file_unique_id,
            duration=self.duration if duration is None else duration,
            mime_type=self.mime_type if mime_type is None else mime_type,
            file_size=self.file_size if file_size is None else file_size,
        )


@dataclasses.dataclass(slots=True)
class Contact:
    """This object represents a phone contact.

    More info: https://core.telegram.org/bots/api#contact"""

    phone_number: str
    "Contact's phone number"
    first_name: str
    "Contact's first name"
    last_name: str | None = None
    "Optional. Contact's last name"
    user_id: int | None = None
    "Optional. Contact's user identifier in Telegram. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier."
    vcard: str | None = None
    "Optional. Additional data about the contact in the form of a vCard"

    def copy_with(
        self,
        phone_number: str | None = None,
        first_name: str | None = None,
        last_name: str | None = None,
        user_id: int | None = None,
        vcard: str | None = None,
    ) -> Contact:
        return Contact(
            phone_number=self.phone_number if phone_number is None else phone_number,
            first_name=self.first_name if first_name is None else first_name,
            last_name=self.last_name if last_name is None else last_name,
            user_id=self.user_id if user_id is None else user_id,
            vcard=self.vcard if vcard is None else vcard,
        )


@dataclasses.dataclass(slots=True)
class Dice:
    """This object represents an animated emoji that displays a random value.

    More info: https://core.telegram.org/bots/api#dice"""

    emoji: str
    "Emoji on which the dice throw animation is based"
    value: int
    'Value of the dice, 1-6 for "", "" and "" base emoji, 1-5 for "" and "" base emoji, 1-64 for "" base emoji'

    def copy_with(
        self,
        emoji: str | None = None,
        value: int | None = None,
    ) -> Dice:
        return Dice(
            emoji=self.emoji if emoji is None else emoji,
            value=self.value if value is None else value,
        )


@dataclasses.dataclass(slots=True)
class PollOption:
    """This object contains information about one answer option in a poll.

    More info: https://core.telegram.org/bots/api#polloption"""

    text: str
    "Option text, 1-100 characters"
    voter_count: int
    "Number of users that voted for this option"

    def copy_with(
        self,
        text: str | None = None,
        voter_count: int | None = None,
    ) -> PollOption:
        return PollOption(
            text=self.text if text is None else text,
            voter_count=self.voter_count if voter_count is None else voter_count,
        )


@dataclasses.dataclass(slots=True)
class PollAnswer:
    """This object represents an answer of a user in a non-anonymous poll.

    More info: https://core.telegram.org/bots/api#pollanswer"""

    poll_id: str
    "Unique poll identifier"
    option_ids: list[int]
    "0-based identifiers of chosen answer options. May be empty if the vote was retracted."
    voter_chat: Chat | None = None
    "Optional. The chat that changed the answer to the poll, if the voter is anonymous"
    user: User | None = None
    "Optional. The user that changed the answer to the poll, if the voter isn't anonymous"

    def copy_with(
        self,
        poll_id: str | None = None,
        voter_chat: Chat | None = None,
        user: User | None = None,
        option_ids: list[int] | None = None,
    ) -> PollAnswer:
        return PollAnswer(
            poll_id=self.poll_id if poll_id is None else poll_id,
            voter_chat=self.voter_chat if voter_chat is None else voter_chat,
            user=self.user if user is None else user,
            option_ids=self.option_ids if option_ids is None else option_ids,
        )


@dataclasses.dataclass(slots=True)
class Poll:
    """This object contains information about a poll.

    More info: https://core.telegram.org/bots/api#poll"""

    id: str
    "Unique poll identifier"
    question: str
    "Poll question, 1-300 characters"
    options: list[PollOption]
    "List of poll options"
    total_voter_count: int
    "Total number of users that voted in the poll"
    is_closed: bool
    "True, if the poll is closed"
    is_anonymous: bool
    "True, if the poll is anonymous"
    type: str
    'Poll type, currently can be "regular" or "quiz"'
    allows_multiple_answers: bool
    "True, if the poll allows multiple answers"
    correct_option_id: int | None = None
    "Optional. 0-based identifier of the correct answer option. Available only for polls in the quiz mode, which are closed, or was sent (not forwarded) by the bot or to the private chat with the bot."
    explanation: str | None = None
    "Optional. Text that is shown when a user chooses an incorrect answer or taps on the lamp icon in a quiz-style poll, 0-200 characters"
    explanation_entities: list[MessageEntity] | None = None
    "Optional. Special entities like usernames, URLs, bot commands, etc. that appear in the explanation"
    open_period: int | None = None
    "Optional. Amount of time in seconds the poll will be active after creation"
    close_date: int | None = None
    "Optional. Point in time (Unix timestamp) when the poll will be automatically closed"

    def copy_with(
        self,
        id: str | None = None,
        question: str | None = None,
        options: list[PollOption] | None = None,
        total_voter_count: int | None = None,
        is_closed: bool | None = None,
        is_anonymous: bool | None = None,
        type: str | None = None,
        allows_multiple_answers: bool | None = None,
        correct_option_id: int | None = None,
        explanation: str | None = None,
        explanation_entities: list[MessageEntity] | None = None,
        open_period: int | None = None,
        close_date: int | None = None,
    ) -> Poll:
        return Poll(
            id=self.id if id is None else id,
            question=self.question if question is None else question,
            options=self.options if options is None else options,
            total_voter_count=self.total_voter_count
            if total_voter_count is None
            else total_voter_count,
            is_closed=self.is_closed if is_closed is None else is_closed,
            is_anonymous=self.is_anonymous if is_anonymous is None else is_anonymous,
            type=self.type if type is None else type,
            allows_multiple_answers=self.allows_multiple_answers
            if allows_multiple_answers is None
            else allows_multiple_answers,
            correct_option_id=self.correct_option_id
            if correct_option_id is None
            else correct_option_id,
            explanation=self.explanation if explanation is None else explanation,
            explanation_entities=self.explanation_entities
            if explanation_entities is None
            else explanation_entities,
            open_period=self.open_period if open_period is None else open_period,
            close_date=self.close_date if close_date is None else close_date,
        )


@dataclasses.dataclass(slots=True)
class Location:
    """This object represents a point on the map.

    More info: https://core.telegram.org/bots/api#location"""

    longitude: float
    "Longitude as defined by sender"
    latitude: float
    "Latitude as defined by sender"
    horizontal_accuracy: float | None = None
    "Optional. The radius of uncertainty for the location, measured in meters; 0-1500"
    live_period: int | None = None
    "Optional. Time relative to the message sending date, during which the location can be updated; in seconds. For active live locations only."
    heading: int | None = None
    "Optional. The direction in which user is moving, in degrees; 1-360. For active live locations only."
    proximity_alert_radius: int | None = None
    "Optional. The maximum distance for proximity alerts about approaching another chat member, in meters. For sent live locations only."

    def copy_with(
        self,
        longitude: float | None = None,
        latitude: float | None = None,
        horizontal_accuracy: float | None = None,
        live_period: int | None = None,
        heading: int | None = None,
        proximity_alert_radius: int | None = None,
    ) -> Location:
        return Location(
            longitude=self.longitude if longitude is None else longitude,
            latitude=self.latitude if latitude is None else latitude,
            horizontal_accuracy=self.horizontal_accuracy
            if horizontal_accuracy is None
            else horizontal_accuracy,
            live_period=self.live_period if live_period is None else live_period,
            heading=self.heading if heading is None else heading,
            proximity_alert_radius=self.proximity_alert_radius
            if proximity_alert_radius is None
            else proximity_alert_radius,
        )


@dataclasses.dataclass(slots=True)
class Venue:
    """This object represents a venue.

    More info: https://core.telegram.org/bots/api#venue"""

    location: Location
    "Venue location. Can't be a live location"
    title: str
    "Name of the venue"
    address: str
    "Address of the venue"
    foursquare_id: str | None = None
    "Optional. Foursquare identifier of the venue"
    foursquare_type: str | None = None
    'Optional. Foursquare type of the venue. (For example, "arts_entertainment/default", "arts_entertainment/aquarium" or "food/icecream".)'
    google_place_id: str | None = None
    "Optional. Google Places identifier of the venue"
    google_place_type: str | None = None
    "Optional. Google Places type of the venue. (See supported types.)"

    def copy_with(
        self,
        location: Location | None = None,
        title: str | None = None,
        address: str | None = None,
        foursquare_id: str | None = None,
        foursquare_type: str | None = None,
        google_place_id: str | None = None,
        google_place_type: str | None = None,
    ) -> Venue:
        return Venue(
            location=self.location if location is None else location,
            title=self.title if title is None else title,
            address=self.address if address is None else address,
            foursquare_id=self.foursquare_id
            if foursquare_id is None
            else foursquare_id,
            foursquare_type=self.foursquare_type
            if foursquare_type is None
            else foursquare_type,
            google_place_id=self.google_place_id
            if google_place_id is None
            else google_place_id,
            google_place_type=self.google_place_type
            if google_place_type is None
            else google_place_type,
        )


@dataclasses.dataclass(slots=True)
class WebAppData:
    """Describes data sent from a Web App to the bot.

    More info: https://core.telegram.org/bots/api#webappdata"""

    data: str
    "The data. Be aware that a bad client can send arbitrary data in this field."
    button_text: str
    "Text of the web_app keyboard button from which the Web App was opened. Be aware that a bad client can send arbitrary data in this field."

    def copy_with(
        self,
        data: str | None = None,
        button_text: str | None = None,
    ) -> WebAppData:
        return WebAppData(
            data=self.data if data is None else data,
            button_text=self.button_text if button_text is None else button_text,
        )


@dataclasses.dataclass(slots=True)
class ProximityAlertTriggered:
    """This object represents the content of a service message, sent whenever a user in the chat triggers a proximity alert set by another user.

    More info: https://core.telegram.org/bots/api#proximityalerttriggered"""

    traveler: User
    "User that triggered the alert"
    watcher: User
    "User that set the alert"
    distance: int
    "The distance between the users"

    def copy_with(
        self,
        traveler: User | None = None,
        watcher: User | None = None,
        distance: int | None = None,
    ) -> ProximityAlertTriggered:
        return ProximityAlertTriggered(
            traveler=self.traveler if traveler is None else traveler,
            watcher=self.watcher if watcher is None else watcher,
            distance=self.distance if distance is None else distance,
        )


@dataclasses.dataclass(slots=True)
class MessageAutoDeleteTimerChanged:
    """This object represents a service message about a change in auto-delete timer settings.

    More info: https://core.telegram.org/bots/api#messageautodeletetimerchanged"""

    message_auto_delete_time: int
    "New auto-delete time for messages in the chat; in seconds"

    def copy_with(
        self,
        message_auto_delete_time: int | None = None,
    ) -> MessageAutoDeleteTimerChanged:
        return MessageAutoDeleteTimerChanged(
            message_auto_delete_time=self.message_auto_delete_time
            if message_auto_delete_time is None
            else message_auto_delete_time
        )


@dataclasses.dataclass(slots=True)
class ForumTopicCreated:
    """This object represents a service message about a new forum topic created in the chat.

    More info: https://core.telegram.org/bots/api#forumtopiccreated"""

    name: str
    "Name of the topic"
    icon_color: int
    "Color of the topic icon in RGB format"
    icon_custom_emoji_id: str | None = None
    "Optional. Unique identifier of the custom emoji shown as the topic icon"

    def copy_with(
        self,
        name: str | None = None,
        icon_color: int | None = None,
        icon_custom_emoji_id: str | None = None,
    ) -> ForumTopicCreated:
        return ForumTopicCreated(
            name=self.name if name is None else name,
            icon_color=self.icon_color if icon_color is None else icon_color,
            icon_custom_emoji_id=self.icon_custom_emoji_id
            if icon_custom_emoji_id is None
            else icon_custom_emoji_id,
        )


@dataclasses.dataclass(slots=True)
class ForumTopicClosed:
    """This object represents a service message about a forum topic closed in the chat. Currently holds no information.

    More info: https://core.telegram.org/bots/api#forumtopicclosed"""

    pass


@dataclasses.dataclass(slots=True)
class ForumTopicEdited:
    """This object represents a service message about an edited forum topic.

    More info: https://core.telegram.org/bots/api#forumtopicedited"""

    name: str | None = None
    "Optional. New name of the topic, if it was edited"
    icon_custom_emoji_id: str | None = None
    "Optional. New identifier of the custom emoji shown as the topic icon, if it was edited; an empty string if the icon was removed"

    def copy_with(
        self,
        name: str | None = None,
        icon_custom_emoji_id: str | None = None,
    ) -> ForumTopicEdited:
        return ForumTopicEdited(
            name=self.name if name is None else name,
            icon_custom_emoji_id=self.icon_custom_emoji_id
            if icon_custom_emoji_id is None
            else icon_custom_emoji_id,
        )


@dataclasses.dataclass(slots=True)
class ForumTopicReopened:
    """This object represents a service message about a forum topic reopened in the chat. Currently holds no information.

    More info: https://core.telegram.org/bots/api#forumtopicreopened"""

    pass


@dataclasses.dataclass(slots=True)
class GeneralForumTopicHidden:
    """This object represents a service message about General forum topic hidden in the chat. Currently holds no information.

    More info: https://core.telegram.org/bots/api#generalforumtopichidden"""

    pass


@dataclasses.dataclass(slots=True)
class GeneralForumTopicUnhidden:
    """This object represents a service message about General forum topic unhidden in the chat. Currently holds no information.

    More info: https://core.telegram.org/bots/api#generalforumtopicunhidden"""

    pass


@dataclasses.dataclass(slots=True)
class UserShared:
    """This object contains information about the user whose identifier was shared with the bot using a KeyboardButtonRequestUser button.

    More info: https://core.telegram.org/bots/api#usershared"""

    request_id: int
    "Identifier of the request"
    user_id: int
    "Identifier of the shared user. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier. The bot may not have access to the user and could be unable to use this identifier, unless the user is already known to the bot by some other means."

    def copy_with(
        self,
        request_id: int | None = None,
        user_id: int | None = None,
    ) -> UserShared:
        return UserShared(
            request_id=self.request_id if request_id is None else request_id,
            user_id=self.user_id if user_id is None else user_id,
        )


@dataclasses.dataclass(slots=True)
class ChatShared:
    """This object contains information about the chat whose identifier was shared with the bot using a KeyboardButtonRequestChat button.

    More info: https://core.telegram.org/bots/api#chatshared"""

    request_id: int
    "Identifier of the request"
    chat_id: int
    "Identifier of the shared chat. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier. The bot may not have access to the chat and could be unable to use this identifier, unless the chat is already known to the bot by some other means."

    def copy_with(
        self,
        request_id: int | None = None,
        chat_id: int | None = None,
    ) -> ChatShared:
        return ChatShared(
            request_id=self.request_id if request_id is None else request_id,
            chat_id=self.chat_id if chat_id is None else chat_id,
        )


@dataclasses.dataclass(slots=True)
class WriteAccessAllowed:
    """This object represents a service message about a user allowing a bot to write messages after adding it to the attachment menu, launching a Web App from a link, or accepting an explicit request from a Web App sent by the method requestWriteAccess.

    More info: https://core.telegram.org/bots/api#writeaccessallowed"""

    from_request: bool | None = None
    "Optional. True, if the access was granted after the user accepted an explicit request from a Web App sent by the method requestWriteAccess"
    web_app_name: str | None = None
    "Optional. Name of the Web App, if the access was granted when the Web App was launched from a link"
    from_attachment_menu: bool | None = None
    "Optional. True, if the access was granted when the bot was added to the attachment or side menu"

    def copy_with(
        self,
        from_request: bool | None = None,
        web_app_name: str | None = None,
        from_attachment_menu: bool | None = None,
    ) -> WriteAccessAllowed:
        return WriteAccessAllowed(
            from_request=self.from_request if from_request is None else from_request,
            web_app_name=self.web_app_name if web_app_name is None else web_app_name,
            from_attachment_menu=self.from_attachment_menu
            if from_attachment_menu is None
            else from_attachment_menu,
        )


@dataclasses.dataclass(slots=True)
class VideoChatScheduled:
    """This object represents a service message about a video chat scheduled in the chat.

    More info: https://core.telegram.org/bots/api#videochatscheduled"""

    start_date: int
    "Point in time (Unix timestamp) when the video chat is supposed to be started by a chat administrator"

    def copy_with(
        self,
        start_date: int | None = None,
    ) -> VideoChatScheduled:
        return VideoChatScheduled(
            start_date=self.start_date if start_date is None else start_date
        )


@dataclasses.dataclass(slots=True)
class VideoChatStarted:
    """This object represents a service message about a video chat started in the chat. Currently holds no information.

    More info: https://core.telegram.org/bots/api#videochatstarted"""

    pass


@dataclasses.dataclass(slots=True)
class VideoChatEnded:
    """This object represents a service message about a video chat ended in the chat.

    More info: https://core.telegram.org/bots/api#videochatended"""

    duration: int
    "Video chat duration in seconds"

    def copy_with(
        self,
        duration: int | None = None,
    ) -> VideoChatEnded:
        return VideoChatEnded(duration=self.duration if duration is None else duration)


@dataclasses.dataclass(slots=True)
class VideoChatParticipantsInvited:
    """This object represents a service message about new members invited to a video chat.

    More info: https://core.telegram.org/bots/api#videochatparticipantsinvited"""

    users: list[User]
    "New members that were invited to the video chat"

    def copy_with(
        self,
        users: list[User] | None = None,
    ) -> VideoChatParticipantsInvited:
        return VideoChatParticipantsInvited(
            users=self.users if users is None else users
        )


@dataclasses.dataclass(slots=True)
class UserProfilePhotos:
    """This object represent a user's profile pictures.

    More info: https://core.telegram.org/bots/api#userprofilephotos"""

    total_count: int
    "Total number of profile pictures the target user has"
    photos: list[list[PhotoSize]]
    "Requested profile pictures (in up to 4 sizes each)"

    def copy_with(
        self,
        total_count: int | None = None,
        photos: list[list[PhotoSize]] | None = None,
    ) -> UserProfilePhotos:
        return UserProfilePhotos(
            total_count=self.total_count if total_count is None else total_count,
            photos=self.photos if photos is None else photos,
        )


@dataclasses.dataclass(slots=True)
class File:
    """This object represents a file ready to be downloaded. The file can be downloaded via the link https://api.telegram.org/file/bot<token>/<file_path>. It is guaranteed that the link will be valid for at least 1 hour. When the link expires, a new one can be requested by calling getFile.

    More info: https://core.telegram.org/bots/api#file"""

    file_id: str
    "Identifier for this file, which can be used to download or reuse the file"
    file_unique_id: str
    "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."
    file_size: int | None = None
    "Optional. File size in bytes. It can be bigger than 2^31 and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this value."
    file_path: str | None = None
    "Optional. File path. Use https://api.telegram.org/file/bot<token>/<file_path> to get the file."

    def copy_with(
        self,
        file_id: str | None = None,
        file_unique_id: str | None = None,
        file_size: int | None = None,
        file_path: str | None = None,
    ) -> File:
        return File(
            file_id=self.file_id if file_id is None else file_id,
            file_unique_id=self.file_unique_id
            if file_unique_id is None
            else file_unique_id,
            file_size=self.file_size if file_size is None else file_size,
            file_path=self.file_path if file_path is None else file_path,
        )


@dataclasses.dataclass(slots=True)
class WebAppInfo:
    """Describes a Web App.

    More info: https://core.telegram.org/bots/api#webappinfo"""

    url: str
    "An HTTPS URL of a Web App to be opened with additional data as specified in Initializing Web Apps"

    def copy_with(
        self,
        url: str | None = None,
    ) -> WebAppInfo:
        return WebAppInfo(url=self.url if url is None else url)


@dataclasses.dataclass(slots=True)
class ReplyKeyboardMarkup:
    """This object represents a custom keyboard with reply options (see Introduction to bots for details and examples).

    More info: https://core.telegram.org/bots/api#replykeyboardmarkup"""

    keyboard: list[list[KeyboardButton]]
    "Array of button rows, each represented by an Array of KeyboardButton objects"
    is_persistent: bool | None = None
    "Optional. Requests clients to always show the keyboard when the regular keyboard is hidden. Defaults to false, in which case the custom keyboard can be hidden and opened with a keyboard icon."
    resize_keyboard: bool | None = None
    "Optional. Requests clients to resize the keyboard vertically for optimal fit (e.g., make the keyboard smaller if there are just two rows of buttons). Defaults to false, in which case the custom keyboard is always of the same height as the app's standard keyboard."
    one_time_keyboard: bool | None = None
    "Optional. Requests clients to hide the keyboard as soon as it's been used. The keyboard will still be available, but clients will automatically display the usual letter-keyboard in the chat - the user can press a special button in the input field to see the custom keyboard again. Defaults to false."
    input_field_placeholder: str | None = None
    "Optional. The placeholder to be shown in the input field when the keyboard is active; 1-64 characters"
    selective: bool | None = None
    "Optional. Use this parameter if you want to show the keyboard to specific users only. Targets: 1) users that are @mentioned in the text of the Message object; 2) if the bot's message is a reply (has reply_to_message_id), sender of the original message. Example: A user requests to change the bot's language, bot replies to the request with a keyboard to select the new language. Other users in the group don't see the keyboard."

    def copy_with(
        self,
        keyboard: list[list[KeyboardButton]] | None = None,
        is_persistent: bool | None = None,
        resize_keyboard: bool | None = None,
        one_time_keyboard: bool | None = None,
        input_field_placeholder: str | None = None,
        selective: bool | None = None,
    ) -> ReplyKeyboardMarkup:
        return ReplyKeyboardMarkup(
            keyboard=self.keyboard if keyboard is None else keyboard,
            is_persistent=self.is_persistent
            if is_persistent is None
            else is_persistent,
            resize_keyboard=self.resize_keyboard
            if resize_keyboard is None
            else resize_keyboard,
            one_time_keyboard=self.one_time_keyboard
            if one_time_keyboard is None
            else one_time_keyboard,
            input_field_placeholder=self.input_field_placeholder
            if input_field_placeholder is None
            else input_field_placeholder,
            selective=self.selective if selective is None else selective,
        )


@dataclasses.dataclass(slots=True)
class KeyboardButton:
    """This object represents one button of the reply keyboard. For simple text buttons, String can be used instead of this object to specify the button text. The optional fields web_app, request_user, request_chat, request_contact, request_location, and request_poll are mutually exclusive.
    Note: request_contact and request_location options will only work in Telegram versions released after 9 April, 2016. Older clients will display unsupported message.
    Note: request_poll option will only work in Telegram versions released after 23 January, 2020. Older clients will display unsupported message.
    Note: web_app option will only work in Telegram versions released after 16 April, 2022. Older clients will display unsupported message.
    Note: request_user and request_chat options will only work in Telegram versions released after 3 February, 2023. Older clients will display unsupported message.

    More info: https://core.telegram.org/bots/api#keyboardbutton"""

    text: str
    "Text of the button. If none of the optional fields are used, it will be sent as a message when the button is pressed"
    request_user: KeyboardButtonRequestUser | None = None
    'Optional. If specified, pressing the button will open a list of suitable users. Tapping on any user will send their identifier to the bot in a "user_shared" service message. Available in private chats only.'
    request_chat: KeyboardButtonRequestChat | None = None
    'Optional. If specified, pressing the button will open a list of suitable chats. Tapping on a chat will send its identifier to the bot in a "chat_shared" service message. Available in private chats only.'
    request_contact: bool | None = None
    "Optional. If True, the user's phone number will be sent as a contact when the button is pressed. Available in private chats only."
    request_location: bool | None = None
    "Optional. If True, the user's current location will be sent when the button is pressed. Available in private chats only."
    request_poll: KeyboardButtonPollType | None = None
    "Optional. If specified, the user will be asked to create a poll and send it to the bot when the button is pressed. Available in private chats only."
    web_app: WebAppInfo | None = None
    'Optional. If specified, the described Web App will be launched when the button is pressed. The Web App will be able to send a "web_app_data" service message. Available in private chats only.'

    def copy_with(
        self,
        text: str | None = None,
        request_user: KeyboardButtonRequestUser | None = None,
        request_chat: KeyboardButtonRequestChat | None = None,
        request_contact: bool | None = None,
        request_location: bool | None = None,
        request_poll: KeyboardButtonPollType | None = None,
        web_app: WebAppInfo | None = None,
    ) -> KeyboardButton:
        return KeyboardButton(
            text=self.text if text is None else text,
            request_user=self.request_user if request_user is None else request_user,
            request_chat=self.request_chat if request_chat is None else request_chat,
            request_contact=self.request_contact
            if request_contact is None
            else request_contact,
            request_location=self.request_location
            if request_location is None
            else request_location,
            request_poll=self.request_poll if request_poll is None else request_poll,
            web_app=self.web_app if web_app is None else web_app,
        )


@dataclasses.dataclass(slots=True)
class KeyboardButtonRequestUser:
    """This object defines the criteria used to request a suitable user. The identifier of the selected user will be shared with the bot when the corresponding button is pressed. More about requesting users: https://core.telegram.org/bots/features#chat-and-user-selection

    More info: https://core.telegram.org/bots/api#keyboardbuttonrequestuser"""

    request_id: int
    "Signed 32-bit identifier of the request, which will be received back in the UserShared object. Must be unique within the message"
    user_is_bot: bool | None = None
    "Optional. Pass True to request a bot, pass False to request a regular user. If not specified, no additional restrictions are applied."
    user_is_premium: bool | None = None
    "Optional. Pass True to request a premium user, pass False to request a non-premium user. If not specified, no additional restrictions are applied."

    def copy_with(
        self,
        request_id: int | None = None,
        user_is_bot: bool | None = None,
        user_is_premium: bool | None = None,
    ) -> KeyboardButtonRequestUser:
        return KeyboardButtonRequestUser(
            request_id=self.request_id if request_id is None else request_id,
            user_is_bot=self.user_is_bot if user_is_bot is None else user_is_bot,
            user_is_premium=self.user_is_premium
            if user_is_premium is None
            else user_is_premium,
        )


@dataclasses.dataclass(slots=True)
class KeyboardButtonRequestChat:
    """This object defines the criteria used to request a suitable chat. The identifier of the selected chat will be shared with the bot when the corresponding button is pressed. More about requesting chats: https://core.telegram.org/bots/features#chat-and-user-selection

    More info: https://core.telegram.org/bots/api#keyboardbuttonrequestchat"""

    request_id: int
    "Signed 32-bit identifier of the request, which will be received back in the ChatShared object. Must be unique within the message"
    chat_is_channel: bool
    "Pass True to request a channel chat, pass False to request a group or a supergroup chat."
    chat_is_forum: bool | None = None
    "Optional. Pass True to request a forum supergroup, pass False to request a non-forum chat. If not specified, no additional restrictions are applied."
    chat_has_username: bool | None = None
    "Optional. Pass True to request a supergroup or a channel with a username, pass False to request a chat without a username. If not specified, no additional restrictions are applied."
    chat_is_created: bool | None = None
    "Optional. Pass True to request a chat owned by the user. Otherwise, no additional restrictions are applied."
    user_administrator_rights: ChatAdministratorRights | None = None
    "Optional. A JSON-serialized object listing the required administrator rights of the user in the chat. The rights must be a superset of bot_administrator_rights. If not specified, no additional restrictions are applied."
    bot_administrator_rights: ChatAdministratorRights | None = None
    "Optional. A JSON-serialized object listing the required administrator rights of the bot in the chat. The rights must be a subset of user_administrator_rights. If not specified, no additional restrictions are applied."
    bot_is_member: bool | None = None
    "Optional. Pass True to request a chat with the bot as a member. Otherwise, no additional restrictions are applied."

    def copy_with(
        self,
        request_id: int | None = None,
        chat_is_channel: bool | None = None,
        chat_is_forum: bool | None = None,
        chat_has_username: bool | None = None,
        chat_is_created: bool | None = None,
        user_administrator_rights: ChatAdministratorRights | None = None,
        bot_administrator_rights: ChatAdministratorRights | None = None,
        bot_is_member: bool | None = None,
    ) -> KeyboardButtonRequestChat:
        return KeyboardButtonRequestChat(
            request_id=self.request_id if request_id is None else request_id,
            chat_is_channel=self.chat_is_channel
            if chat_is_channel is None
            else chat_is_channel,
            chat_is_forum=self.chat_is_forum
            if chat_is_forum is None
            else chat_is_forum,
            chat_has_username=self.chat_has_username
            if chat_has_username is None
            else chat_has_username,
            chat_is_created=self.chat_is_created
            if chat_is_created is None
            else chat_is_created,
            user_administrator_rights=self.user_administrator_rights
            if user_administrator_rights is None
            else user_administrator_rights,
            bot_administrator_rights=self.bot_administrator_rights
            if bot_administrator_rights is None
            else bot_administrator_rights,
            bot_is_member=self.bot_is_member
            if bot_is_member is None
            else bot_is_member,
        )


@dataclasses.dataclass(slots=True)
class KeyboardButtonPollType:
    """This object represents type of a poll, which is allowed to be created and sent when the corresponding button is pressed.

    More info: https://core.telegram.org/bots/api#keyboardbuttonpolltype"""

    type: str | None = None
    "Optional. If quiz is passed, the user will be allowed to create only polls in the quiz mode. If regular is passed, only regular polls will be allowed. Otherwise, the user will be allowed to create a poll of any type."

    def copy_with(
        self,
        type: str | None = None,
    ) -> KeyboardButtonPollType:
        return KeyboardButtonPollType(type=self.type if type is None else type)


@dataclasses.dataclass(slots=True)
class ReplyKeyboardRemove:
    """Upon receiving a message with this object, Telegram clients will remove the current custom keyboard and display the default letter-keyboard. By default, custom keyboards are displayed until a new keyboard is sent by a bot. An exception is made for one-time keyboards that are hidden immediately after the user presses a button (see ReplyKeyboardMarkup).

    More info: https://core.telegram.org/bots/api#replykeyboardremove"""

    remove_keyboard: bool
    "Requests clients to remove the custom keyboard (user will not be able to summon this keyboard; if you want to hide the keyboard from sight but keep it accessible, use one_time_keyboard in ReplyKeyboardMarkup)"
    selective: bool | None = None
    "Optional. Use this parameter if you want to remove the keyboard for specific users only. Targets: 1) users that are @mentioned in the text of the Message object; 2) if the bot's message is a reply (has reply_to_message_id), sender of the original message. Example: A user votes in a poll, bot returns confirmation message in reply to the vote and removes the keyboard for that user, while still showing the keyboard with poll options to users who haven't voted yet."

    def copy_with(
        self,
        remove_keyboard: bool | None = None,
        selective: bool | None = None,
    ) -> ReplyKeyboardRemove:
        return ReplyKeyboardRemove(
            remove_keyboard=self.remove_keyboard
            if remove_keyboard is None
            else remove_keyboard,
            selective=self.selective if selective is None else selective,
        )


@dataclasses.dataclass(slots=True)
class InlineKeyboardMarkup:
    """This object represents an inline keyboard that appears right next to the message it belongs to.
    Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will display unsupported message.

    More info: https://core.telegram.org/bots/api#inlinekeyboardmarkup"""

    inline_keyboard: list[list[InlineKeyboardButton]]
    "Array of button rows, each represented by an Array of InlineKeyboardButton objects"

    def copy_with(
        self,
        inline_keyboard: list[list[InlineKeyboardButton]] | None = None,
    ) -> InlineKeyboardMarkup:
        return InlineKeyboardMarkup(
            inline_keyboard=self.inline_keyboard
            if inline_keyboard is None
            else inline_keyboard
        )


@dataclasses.dataclass(slots=True)
class InlineKeyboardButton:
    """This object represents one button of an inline keyboard. You must use exactly one of the optional fields.

    More info: https://core.telegram.org/bots/api#inlinekeyboardbutton"""

    text: str
    "Label text on the button"
    url: str | None = None
    "Optional. HTTP or tg:// URL to be opened when the button is pressed. Links tg://user?id=<user_id> can be used to mention a user by their ID without using a username, if this is allowed by their privacy settings."
    callback_data: str | None = None
    "Optional. Data to be sent in a callback query to the bot when button is pressed, 1-64 bytes"
    web_app: WebAppInfo | None = None
    "Optional. Description of the Web App that will be launched when the user presses the button. The Web App will be able to send an arbitrary message on behalf of the user using the method answerWebAppQuery. Available only in private chats between a user and the bot."
    login_url: LoginUrl | None = None
    "Optional. An HTTPS URL used to automatically authorize the user. Can be used as a replacement for the Telegram Login Widget."
    switch_inline_query: str | None = None
    "Optional. If set, pressing the button will prompt the user to select one of their chats, open that chat and insert the bot's username and the specified inline query in the input field. May be empty, in which case just the bot's username will be inserted."
    switch_inline_query_current_chat: str | None = None
    "Optional. If set, pressing the button will insert the bot's username and the specified inline query in the current chat's input field. May be empty, in which case only the bot's username will be inserted. This offers a quick way for the user to open your bot in inline mode in the same chat - good for selecting something from multiple options."
    switch_inline_query_chosen_chat: SwitchInlineQueryChosenChat | None = None
    "Optional. If set, pressing the button will prompt the user to select one of their chats of the specified type, open that chat and insert the bot's username and the specified inline query in the input field"
    callback_game: CallbackGame | None = None
    "Optional. Description of the game that will be launched when the user presses the button. NOTE: This type of button must always be the first button in the first row."
    pay: bool | None = None
    "Optional. Specify True, to send a Pay button. NOTE: This type of button must always be the first button in the first row and can only be used in invoice messages."

    def copy_with(
        self,
        text: str | None = None,
        url: str | None = None,
        callback_data: str | None = None,
        web_app: WebAppInfo | None = None,
        login_url: LoginUrl | None = None,
        switch_inline_query: str | None = None,
        switch_inline_query_current_chat: str | None = None,
        switch_inline_query_chosen_chat: SwitchInlineQueryChosenChat | None = None,
        callback_game: CallbackGame | None = None,
        pay: bool | None = None,
    ) -> InlineKeyboardButton:
        return InlineKeyboardButton(
            text=self.text if text is None else text,
            url=self.url if url is None else url,
            callback_data=self.callback_data
            if callback_data is None
            else callback_data,
            web_app=self.web_app if web_app is None else web_app,
            login_url=self.login_url if login_url is None else login_url,
            switch_inline_query=self.switch_inline_query
            if switch_inline_query is None
            else switch_inline_query,
            switch_inline_query_current_chat=self.switch_inline_query_current_chat
            if switch_inline_query_current_chat is None
            else switch_inline_query_current_chat,
            switch_inline_query_chosen_chat=self.switch_inline_query_chosen_chat
            if switch_inline_query_chosen_chat is None
            else switch_inline_query_chosen_chat,
            callback_game=self.callback_game
            if callback_game is None
            else callback_game,
            pay=self.pay if pay is None else pay,
        )


@dataclasses.dataclass(slots=True)
class LoginUrl:
    """This object represents a parameter of the inline keyboard button used to automatically authorize a user. Serves as a great replacement for the Telegram Login Widget when the user is coming from Telegram. All the user needs to do is tap/click a button and confirm that they want to log in:
    Telegram apps support these buttons as of version 5.7.

    More info: https://core.telegram.org/bots/api#loginurl"""

    url: str
    "An HTTPS URL to be opened with user authorization data added to the query string when the button is pressed. If the user refuses to provide authorization data, the original URL without information about the user will be opened. The data added is the same as described in Receiving authorization data. NOTE: You must always check the hash of the received data to verify the authentication and the integrity of the data as described in Checking authorization."
    forward_text: str | None = None
    "Optional. New text of the button in forwarded messages."
    bot_username: str | None = None
    "Optional. Username of a bot, which will be used for user authorization. See Setting up a bot for more details. If not specified, the current bot's username will be assumed. The url's domain must be the same as the domain linked with the bot. See Linking your domain to the bot for more details."
    request_write_access: bool | None = None
    "Optional. Pass True to request the permission for your bot to send messages to the user."

    def copy_with(
        self,
        url: str | None = None,
        forward_text: str | None = None,
        bot_username: str | None = None,
        request_write_access: bool | None = None,
    ) -> LoginUrl:
        return LoginUrl(
            url=self.url if url is None else url,
            forward_text=self.forward_text if forward_text is None else forward_text,
            bot_username=self.bot_username if bot_username is None else bot_username,
            request_write_access=self.request_write_access
            if request_write_access is None
            else request_write_access,
        )


@dataclasses.dataclass(slots=True)
class SwitchInlineQueryChosenChat:
    """This object represents an inline button that switches the current user to inline mode in a chosen chat, with an optional default inline query.

    More info: https://core.telegram.org/bots/api#switchinlinequerychosenchat"""

    query: str | None = None
    "Optional. The default inline query to be inserted in the input field. If left empty, only the bot's username will be inserted"
    allow_user_chats: bool | None = None
    "Optional. True, if private chats with users can be chosen"
    allow_bot_chats: bool | None = None
    "Optional. True, if private chats with bots can be chosen"
    allow_group_chats: bool | None = None
    "Optional. True, if group and supergroup chats can be chosen"
    allow_channel_chats: bool | None = None
    "Optional. True, if channel chats can be chosen"

    def copy_with(
        self,
        query: str | None = None,
        allow_user_chats: bool | None = None,
        allow_bot_chats: bool | None = None,
        allow_group_chats: bool | None = None,
        allow_channel_chats: bool | None = None,
    ) -> SwitchInlineQueryChosenChat:
        return SwitchInlineQueryChosenChat(
            query=self.query if query is None else query,
            allow_user_chats=self.allow_user_chats
            if allow_user_chats is None
            else allow_user_chats,
            allow_bot_chats=self.allow_bot_chats
            if allow_bot_chats is None
            else allow_bot_chats,
            allow_group_chats=self.allow_group_chats
            if allow_group_chats is None
            else allow_group_chats,
            allow_channel_chats=self.allow_channel_chats
            if allow_channel_chats is None
            else allow_channel_chats,
        )


@dataclasses.dataclass(slots=True)
class CallbackQuery:
    """This object represents an incoming callback query from a callback button in an inline keyboard. If the button that originated the query was attached to a message sent by the bot, the field message will be present. If the button was attached to a message sent via the bot (in inline mode), the field inline_message_id will be present. Exactly one of the fields data or game_short_name will be present.

    More info: https://core.telegram.org/bots/api#callbackquery"""

    id: str
    "Unique identifier for this query"
    from_: User
    "Sender"
    chat_instance: str
    "Global identifier, uniquely corresponding to the chat to which the message with the callback button was sent. Useful for high scores in games."
    message: Message | None = None
    "Optional. Message with the callback button that originated the query. Note that message content and message date will not be available if the message is too old"
    inline_message_id: str | None = None
    "Optional. Identifier of the message sent via the bot in inline mode, that originated the query."
    data: str | None = None
    "Optional. Data associated with the callback button. Be aware that the message originated the query can contain no callback buttons with this data."
    game_short_name: str | None = None
    "Optional. Short name of a Game to be returned, serves as the unique identifier for the game"

    def copy_with(
        self,
        id: str | None = None,
        from_: User | None = None,
        message: Message | None = None,
        inline_message_id: str | None = None,
        chat_instance: str | None = None,
        data: str | None = None,
        game_short_name: str | None = None,
    ) -> CallbackQuery:
        return CallbackQuery(
            id=self.id if id is None else id,
            from_=self.from_ if from_ is None else from_,
            message=self.message if message is None else message,
            inline_message_id=self.inline_message_id
            if inline_message_id is None
            else inline_message_id,
            chat_instance=self.chat_instance
            if chat_instance is None
            else chat_instance,
            data=self.data if data is None else data,
            game_short_name=self.game_short_name
            if game_short_name is None
            else game_short_name,
        )


@dataclasses.dataclass(slots=True)
class ForceReply:
    """Upon receiving a message with this object, Telegram clients will display a reply interface to the user (act as if the user has selected the bot's message and tapped 'Reply'). This can be extremely useful if you want to create user-friendly step-by-step interfaces without having to sacrifice privacy mode.

    More info: https://core.telegram.org/bots/api#forcereply"""

    force_reply: bool
    "Shows reply interface to the user, as if they manually selected the bot's message and tapped 'Reply'"
    input_field_placeholder: str | None = None
    "Optional. The placeholder to be shown in the input field when the reply is active; 1-64 characters"
    selective: bool | None = None
    "Optional. Use this parameter if you want to force reply from specific users only. Targets: 1) users that are @mentioned in the text of the Message object; 2) if the bot's message is a reply (has reply_to_message_id), sender of the original message."

    def copy_with(
        self,
        force_reply: bool | None = None,
        input_field_placeholder: str | None = None,
        selective: bool | None = None,
    ) -> ForceReply:
        return ForceReply(
            force_reply=self.force_reply if force_reply is None else force_reply,
            input_field_placeholder=self.input_field_placeholder
            if input_field_placeholder is None
            else input_field_placeholder,
            selective=self.selective if selective is None else selective,
        )


@dataclasses.dataclass(slots=True)
class ChatPhoto:
    """This object represents a chat photo.

    More info: https://core.telegram.org/bots/api#chatphoto"""

    small_file_id: str
    "File identifier of small (160x160) chat photo. This file_id can be used only for photo download and only for as long as the photo is not changed."
    small_file_unique_id: str
    "Unique file identifier of small (160x160) chat photo, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."
    big_file_id: str
    "File identifier of big (640x640) chat photo. This file_id can be used only for photo download and only for as long as the photo is not changed."
    big_file_unique_id: str
    "Unique file identifier of big (640x640) chat photo, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."

    def copy_with(
        self,
        small_file_id: str | None = None,
        small_file_unique_id: str | None = None,
        big_file_id: str | None = None,
        big_file_unique_id: str | None = None,
    ) -> ChatPhoto:
        return ChatPhoto(
            small_file_id=self.small_file_id
            if small_file_id is None
            else small_file_id,
            small_file_unique_id=self.small_file_unique_id
            if small_file_unique_id is None
            else small_file_unique_id,
            big_file_id=self.big_file_id if big_file_id is None else big_file_id,
            big_file_unique_id=self.big_file_unique_id
            if big_file_unique_id is None
            else big_file_unique_id,
        )


@dataclasses.dataclass(slots=True)
class ChatInviteLink:
    """Represents an invite link for a chat.

    More info: https://core.telegram.org/bots/api#chatinvitelink"""

    invite_link: str
    'The invite link. If the link was created by another chat administrator, then the second part of the link will be replaced with "...".'
    creator: User
    "Creator of the link"
    creates_join_request: bool
    "True, if users joining the chat via the link need to be approved by chat administrators"
    is_primary: bool
    "True, if the link is primary"
    is_revoked: bool
    "True, if the link is revoked"
    name: str | None = None
    "Optional. Invite link name"
    expire_date: int | None = None
    "Optional. Point in time (Unix timestamp) when the link will expire or has been expired"
    member_limit: int | None = None
    "Optional. The maximum number of users that can be members of the chat simultaneously after joining the chat via this invite link; 1-99999"
    pending_join_request_count: int | None = None
    "Optional. Number of pending join requests created using this link"

    def copy_with(
        self,
        invite_link: str | None = None,
        creator: User | None = None,
        creates_join_request: bool | None = None,
        is_primary: bool | None = None,
        is_revoked: bool | None = None,
        name: str | None = None,
        expire_date: int | None = None,
        member_limit: int | None = None,
        pending_join_request_count: int | None = None,
    ) -> ChatInviteLink:
        return ChatInviteLink(
            invite_link=self.invite_link if invite_link is None else invite_link,
            creator=self.creator if creator is None else creator,
            creates_join_request=self.creates_join_request
            if creates_join_request is None
            else creates_join_request,
            is_primary=self.is_primary if is_primary is None else is_primary,
            is_revoked=self.is_revoked if is_revoked is None else is_revoked,
            name=self.name if name is None else name,
            expire_date=self.expire_date if expire_date is None else expire_date,
            member_limit=self.member_limit if member_limit is None else member_limit,
            pending_join_request_count=self.pending_join_request_count
            if pending_join_request_count is None
            else pending_join_request_count,
        )


@dataclasses.dataclass(slots=True)
class ChatAdministratorRights:
    """Represents the rights of an administrator in a chat.

    More info: https://core.telegram.org/bots/api#chatadministratorrights"""

    is_anonymous: bool
    "True, if the user's presence in the chat is hidden"
    can_manage_chat: bool
    "True, if the administrator can access the chat event log, boost list in channels, see channel members, report spam messages, see anonymous administrators in supergroups and ignore slow mode. Implied by any other administrator privilege"
    can_delete_messages: bool
    "True, if the administrator can delete messages of other users"
    can_manage_video_chats: bool
    "True, if the administrator can manage video chats"
    can_restrict_members: bool
    "True, if the administrator can restrict, ban or unban chat members, or access supergroup statistics"
    can_promote_members: bool
    "True, if the administrator can add new administrators with a subset of their own privileges or demote administrators that they have promoted, directly or indirectly (promoted by administrators that were appointed by the user)"
    can_change_info: bool
    "True, if the user is allowed to change the chat title, photo and other settings"
    can_invite_users: bool
    "True, if the user is allowed to invite new users to the chat"
    can_post_messages: bool | None = None
    "Optional. True, if the administrator can post messages in the channel, or access channel statistics; channels only"
    can_edit_messages: bool | None = None
    "Optional. True, if the administrator can edit messages of other users and can pin messages; channels only"
    can_pin_messages: bool | None = None
    "Optional. True, if the user is allowed to pin messages; groups and supergroups only"
    can_post_stories: bool | None = None
    "Optional. True, if the administrator can post stories in the channel; channels only"
    can_edit_stories: bool | None = None
    "Optional. True, if the administrator can edit stories posted by other users; channels only"
    can_delete_stories: bool | None = None
    "Optional. True, if the administrator can delete stories posted by other users; channels only"
    can_manage_topics: bool | None = None
    "Optional. True, if the user is allowed to create, rename, close, and reopen forum topics; supergroups only"

    def copy_with(
        self,
        is_anonymous: bool | None = None,
        can_manage_chat: bool | None = None,
        can_delete_messages: bool | None = None,
        can_manage_video_chats: bool | None = None,
        can_restrict_members: bool | None = None,
        can_promote_members: bool | None = None,
        can_change_info: bool | None = None,
        can_invite_users: bool | None = None,
        can_post_messages: bool | None = None,
        can_edit_messages: bool | None = None,
        can_pin_messages: bool | None = None,
        can_post_stories: bool | None = None,
        can_edit_stories: bool | None = None,
        can_delete_stories: bool | None = None,
        can_manage_topics: bool | None = None,
    ) -> ChatAdministratorRights:
        return ChatAdministratorRights(
            is_anonymous=self.is_anonymous if is_anonymous is None else is_anonymous,
            can_manage_chat=self.can_manage_chat
            if can_manage_chat is None
            else can_manage_chat,
            can_delete_messages=self.can_delete_messages
            if can_delete_messages is None
            else can_delete_messages,
            can_manage_video_chats=self.can_manage_video_chats
            if can_manage_video_chats is None
            else can_manage_video_chats,
            can_restrict_members=self.can_restrict_members
            if can_restrict_members is None
            else can_restrict_members,
            can_promote_members=self.can_promote_members
            if can_promote_members is None
            else can_promote_members,
            can_change_info=self.can_change_info
            if can_change_info is None
            else can_change_info,
            can_invite_users=self.can_invite_users
            if can_invite_users is None
            else can_invite_users,
            can_post_messages=self.can_post_messages
            if can_post_messages is None
            else can_post_messages,
            can_edit_messages=self.can_edit_messages
            if can_edit_messages is None
            else can_edit_messages,
            can_pin_messages=self.can_pin_messages
            if can_pin_messages is None
            else can_pin_messages,
            can_post_stories=self.can_post_stories
            if can_post_stories is None
            else can_post_stories,
            can_edit_stories=self.can_edit_stories
            if can_edit_stories is None
            else can_edit_stories,
            can_delete_stories=self.can_delete_stories
            if can_delete_stories is None
            else can_delete_stories,
            can_manage_topics=self.can_manage_topics
            if can_manage_topics is None
            else can_manage_topics,
        )


@dataclasses.dataclass(slots=True)
class ChatMemberOwner:
    """Represents a chat member that owns the chat and has all administrator privileges.

    More info: https://core.telegram.org/bots/api#chatmemberowner"""

    status: str
    'The member\'s status in the chat, always "creator"'
    user: User
    "Information about the user"
    is_anonymous: bool
    "True, if the user's presence in the chat is hidden"
    custom_title: str | None = None
    "Optional. Custom title for this user"

    def copy_with(
        self,
        status: str | None = None,
        user: User | None = None,
        is_anonymous: bool | None = None,
        custom_title: str | None = None,
    ) -> ChatMemberOwner:
        return ChatMemberOwner(
            status=self.status if status is None else status,
            user=self.user if user is None else user,
            is_anonymous=self.is_anonymous if is_anonymous is None else is_anonymous,
            custom_title=self.custom_title if custom_title is None else custom_title,
        )


@dataclasses.dataclass(slots=True)
class ChatMemberAdministrator:
    """Represents a chat member that has some additional privileges.

    More info: https://core.telegram.org/bots/api#chatmemberadministrator"""

    status: str
    'The member\'s status in the chat, always "administrator"'
    user: User
    "Information about the user"
    can_be_edited: bool
    "True, if the bot is allowed to edit administrator privileges of that user"
    is_anonymous: bool
    "True, if the user's presence in the chat is hidden"
    can_manage_chat: bool
    "True, if the administrator can access the chat event log, boost list in channels, see channel members, report spam messages, see anonymous administrators in supergroups and ignore slow mode. Implied by any other administrator privilege"
    can_delete_messages: bool
    "True, if the administrator can delete messages of other users"
    can_manage_video_chats: bool
    "True, if the administrator can manage video chats"
    can_restrict_members: bool
    "True, if the administrator can restrict, ban or unban chat members, or access supergroup statistics"
    can_promote_members: bool
    "True, if the administrator can add new administrators with a subset of their own privileges or demote administrators that they have promoted, directly or indirectly (promoted by administrators that were appointed by the user)"
    can_change_info: bool
    "True, if the user is allowed to change the chat title, photo and other settings"
    can_invite_users: bool
    "True, if the user is allowed to invite new users to the chat"
    can_post_messages: bool | None = None
    "Optional. True, if the administrator can post messages in the channel, or access channel statistics; channels only"
    can_edit_messages: bool | None = None
    "Optional. True, if the administrator can edit messages of other users and can pin messages; channels only"
    can_pin_messages: bool | None = None
    "Optional. True, if the user is allowed to pin messages; groups and supergroups only"
    can_post_stories: bool | None = None
    "Optional. True, if the administrator can post stories in the channel; channels only"
    can_edit_stories: bool | None = None
    "Optional. True, if the administrator can edit stories posted by other users; channels only"
    can_delete_stories: bool | None = None
    "Optional. True, if the administrator can delete stories posted by other users; channels only"
    can_manage_topics: bool | None = None
    "Optional. True, if the user is allowed to create, rename, close, and reopen forum topics; supergroups only"
    custom_title: str | None = None
    "Optional. Custom title for this user"

    def copy_with(
        self,
        status: str | None = None,
        user: User | None = None,
        can_be_edited: bool | None = None,
        is_anonymous: bool | None = None,
        can_manage_chat: bool | None = None,
        can_delete_messages: bool | None = None,
        can_manage_video_chats: bool | None = None,
        can_restrict_members: bool | None = None,
        can_promote_members: bool | None = None,
        can_change_info: bool | None = None,
        can_invite_users: bool | None = None,
        can_post_messages: bool | None = None,
        can_edit_messages: bool | None = None,
        can_pin_messages: bool | None = None,
        can_post_stories: bool | None = None,
        can_edit_stories: bool | None = None,
        can_delete_stories: bool | None = None,
        can_manage_topics: bool | None = None,
        custom_title: str | None = None,
    ) -> ChatMemberAdministrator:
        return ChatMemberAdministrator(
            status=self.status if status is None else status,
            user=self.user if user is None else user,
            can_be_edited=self.can_be_edited
            if can_be_edited is None
            else can_be_edited,
            is_anonymous=self.is_anonymous if is_anonymous is None else is_anonymous,
            can_manage_chat=self.can_manage_chat
            if can_manage_chat is None
            else can_manage_chat,
            can_delete_messages=self.can_delete_messages
            if can_delete_messages is None
            else can_delete_messages,
            can_manage_video_chats=self.can_manage_video_chats
            if can_manage_video_chats is None
            else can_manage_video_chats,
            can_restrict_members=self.can_restrict_members
            if can_restrict_members is None
            else can_restrict_members,
            can_promote_members=self.can_promote_members
            if can_promote_members is None
            else can_promote_members,
            can_change_info=self.can_change_info
            if can_change_info is None
            else can_change_info,
            can_invite_users=self.can_invite_users
            if can_invite_users is None
            else can_invite_users,
            can_post_messages=self.can_post_messages
            if can_post_messages is None
            else can_post_messages,
            can_edit_messages=self.can_edit_messages
            if can_edit_messages is None
            else can_edit_messages,
            can_pin_messages=self.can_pin_messages
            if can_pin_messages is None
            else can_pin_messages,
            can_post_stories=self.can_post_stories
            if can_post_stories is None
            else can_post_stories,
            can_edit_stories=self.can_edit_stories
            if can_edit_stories is None
            else can_edit_stories,
            can_delete_stories=self.can_delete_stories
            if can_delete_stories is None
            else can_delete_stories,
            can_manage_topics=self.can_manage_topics
            if can_manage_topics is None
            else can_manage_topics,
            custom_title=self.custom_title if custom_title is None else custom_title,
        )


@dataclasses.dataclass(slots=True)
class ChatMemberMember:
    """Represents a chat member that has no additional privileges or restrictions.

    More info: https://core.telegram.org/bots/api#chatmembermember"""

    status: str
    'The member\'s status in the chat, always "member"'
    user: User
    "Information about the user"

    def copy_with(
        self,
        status: str | None = None,
        user: User | None = None,
    ) -> ChatMemberMember:
        return ChatMemberMember(
            status=self.status if status is None else status,
            user=self.user if user is None else user,
        )


@dataclasses.dataclass(slots=True)
class ChatMemberRestricted:
    """Represents a chat member that is under certain restrictions in the chat. Supergroups only.

    More info: https://core.telegram.org/bots/api#chatmemberrestricted"""

    status: str
    'The member\'s status in the chat, always "restricted"'
    user: User
    "Information about the user"
    is_member: bool
    "True, if the user is a member of the chat at the moment of the request"
    can_send_messages: bool
    "True, if the user is allowed to send text messages, contacts, invoices, locations and venues"
    can_send_audios: bool
    "True, if the user is allowed to send audios"
    can_send_documents: bool
    "True, if the user is allowed to send documents"
    can_send_photos: bool
    "True, if the user is allowed to send photos"
    can_send_videos: bool
    "True, if the user is allowed to send videos"
    can_send_video_notes: bool
    "True, if the user is allowed to send video notes"
    can_send_voice_notes: bool
    "True, if the user is allowed to send voice notes"
    can_send_polls: bool
    "True, if the user is allowed to send polls"
    can_send_other_messages: bool
    "True, if the user is allowed to send animations, games, stickers and use inline bots"
    can_add_web_page_previews: bool
    "True, if the user is allowed to add web page previews to their messages"
    can_change_info: bool
    "True, if the user is allowed to change the chat title, photo and other settings"
    can_invite_users: bool
    "True, if the user is allowed to invite new users to the chat"
    can_pin_messages: bool
    "True, if the user is allowed to pin messages"
    can_manage_topics: bool
    "True, if the user is allowed to create forum topics"
    until_date: int
    "Date when restrictions will be lifted for this user; Unix time. If 0, then the user is restricted forever"

    def copy_with(
        self,
        status: str | None = None,
        user: User | None = None,
        is_member: bool | None = None,
        can_send_messages: bool | None = None,
        can_send_audios: bool | None = None,
        can_send_documents: bool | None = None,
        can_send_photos: bool | None = None,
        can_send_videos: bool | None = None,
        can_send_video_notes: bool | None = None,
        can_send_voice_notes: bool | None = None,
        can_send_polls: bool | None = None,
        can_send_other_messages: bool | None = None,
        can_add_web_page_previews: bool | None = None,
        can_change_info: bool | None = None,
        can_invite_users: bool | None = None,
        can_pin_messages: bool | None = None,
        can_manage_topics: bool | None = None,
        until_date: int | None = None,
    ) -> ChatMemberRestricted:
        return ChatMemberRestricted(
            status=self.status if status is None else status,
            user=self.user if user is None else user,
            is_member=self.is_member if is_member is None else is_member,
            can_send_messages=self.can_send_messages
            if can_send_messages is None
            else can_send_messages,
            can_send_audios=self.can_send_audios
            if can_send_audios is None
            else can_send_audios,
            can_send_documents=self.can_send_documents
            if can_send_documents is None
            else can_send_documents,
            can_send_photos=self.can_send_photos
            if can_send_photos is None
            else can_send_photos,
            can_send_videos=self.can_send_videos
            if can_send_videos is None
            else can_send_videos,
            can_send_video_notes=self.can_send_video_notes
            if can_send_video_notes is None
            else can_send_video_notes,
            can_send_voice_notes=self.can_send_voice_notes
            if can_send_voice_notes is None
            else can_send_voice_notes,
            can_send_polls=self.can_send_polls
            if can_send_polls is None
            else can_send_polls,
            can_send_other_messages=self.can_send_other_messages
            if can_send_other_messages is None
            else can_send_other_messages,
            can_add_web_page_previews=self.can_add_web_page_previews
            if can_add_web_page_previews is None
            else can_add_web_page_previews,
            can_change_info=self.can_change_info
            if can_change_info is None
            else can_change_info,
            can_invite_users=self.can_invite_users
            if can_invite_users is None
            else can_invite_users,
            can_pin_messages=self.can_pin_messages
            if can_pin_messages is None
            else can_pin_messages,
            can_manage_topics=self.can_manage_topics
            if can_manage_topics is None
            else can_manage_topics,
            until_date=self.until_date if until_date is None else until_date,
        )


@dataclasses.dataclass(slots=True)
class ChatMemberLeft:
    """Represents a chat member that isn't currently a member of the chat, but may join it themselves.

    More info: https://core.telegram.org/bots/api#chatmemberleft"""

    status: str
    'The member\'s status in the chat, always "left"'
    user: User
    "Information about the user"

    def copy_with(
        self,
        status: str | None = None,
        user: User | None = None,
    ) -> ChatMemberLeft:
        return ChatMemberLeft(
            status=self.status if status is None else status,
            user=self.user if user is None else user,
        )


@dataclasses.dataclass(slots=True)
class ChatMemberBanned:
    """Represents a chat member that was banned in the chat and can't return to the chat or view chat messages.

    More info: https://core.telegram.org/bots/api#chatmemberbanned"""

    status: str
    'The member\'s status in the chat, always "kicked"'
    user: User
    "Information about the user"
    until_date: int
    "Date when restrictions will be lifted for this user; Unix time. If 0, then the user is banned forever"

    def copy_with(
        self,
        status: str | None = None,
        user: User | None = None,
        until_date: int | None = None,
    ) -> ChatMemberBanned:
        return ChatMemberBanned(
            status=self.status if status is None else status,
            user=self.user if user is None else user,
            until_date=self.until_date if until_date is None else until_date,
        )


@dataclasses.dataclass(slots=True)
class ChatMemberUpdated:
    """This object represents changes in the status of a chat member.

    More info: https://core.telegram.org/bots/api#chatmemberupdated"""

    chat: Chat
    "Chat the user belongs to"
    from_: User
    "Performer of the action, which resulted in the change"
    date: int
    "Date the change was done in Unix time"
    old_chat_member: ChatMember
    "Previous information about the chat member"
    new_chat_member: ChatMember
    "New information about the chat member"
    invite_link: ChatInviteLink | None = None
    "Optional. Chat invite link, which was used by the user to join the chat; for joining by invite link events only."
    via_chat_folder_invite_link: bool | None = None
    "Optional. True, if the user joined the chat via a chat folder invite link"

    def copy_with(
        self,
        chat: Chat | None = None,
        from_: User | None = None,
        date: int | None = None,
        old_chat_member: ChatMember | None = None,
        new_chat_member: ChatMember | None = None,
        invite_link: ChatInviteLink | None = None,
        via_chat_folder_invite_link: bool | None = None,
    ) -> ChatMemberUpdated:
        return ChatMemberUpdated(
            chat=self.chat if chat is None else chat,
            from_=self.from_ if from_ is None else from_,
            date=self.date if date is None else date,
            old_chat_member=self.old_chat_member
            if old_chat_member is None
            else old_chat_member,
            new_chat_member=self.new_chat_member
            if new_chat_member is None
            else new_chat_member,
            invite_link=self.invite_link if invite_link is None else invite_link,
            via_chat_folder_invite_link=self.via_chat_folder_invite_link
            if via_chat_folder_invite_link is None
            else via_chat_folder_invite_link,
        )


@dataclasses.dataclass(slots=True)
class ChatJoinRequest:
    """Represents a join request sent to a chat.

    More info: https://core.telegram.org/bots/api#chatjoinrequest"""

    chat: Chat
    "Chat to which the request was sent"
    from_: User
    "User that sent the join request"
    user_chat_id: int
    "Identifier of a private chat with the user who sent the join request. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a 64-bit integer or double-precision float type are safe for storing this identifier. The bot can use this identifier for 5 minutes to send messages until the join request is processed, assuming no other administrator contacted the user."
    date: int
    "Date the request was sent in Unix time"
    bio: str | None = None
    "Optional. Bio of the user."
    invite_link: ChatInviteLink | None = None
    "Optional. Chat invite link that was used by the user to send the join request"

    def copy_with(
        self,
        chat: Chat | None = None,
        from_: User | None = None,
        user_chat_id: int | None = None,
        date: int | None = None,
        bio: str | None = None,
        invite_link: ChatInviteLink | None = None,
    ) -> ChatJoinRequest:
        return ChatJoinRequest(
            chat=self.chat if chat is None else chat,
            from_=self.from_ if from_ is None else from_,
            user_chat_id=self.user_chat_id if user_chat_id is None else user_chat_id,
            date=self.date if date is None else date,
            bio=self.bio if bio is None else bio,
            invite_link=self.invite_link if invite_link is None else invite_link,
        )


@dataclasses.dataclass(slots=True)
class ChatPermissions:
    """Describes actions that a non-administrator user is allowed to take in a chat.

    More info: https://core.telegram.org/bots/api#chatpermissions"""

    can_send_messages: bool | None = None
    "Optional. True, if the user is allowed to send text messages, contacts, invoices, locations and venues"
    can_send_audios: bool | None = None
    "Optional. True, if the user is allowed to send audios"
    can_send_documents: bool | None = None
    "Optional. True, if the user is allowed to send documents"
    can_send_photos: bool | None = None
    "Optional. True, if the user is allowed to send photos"
    can_send_videos: bool | None = None
    "Optional. True, if the user is allowed to send videos"
    can_send_video_notes: bool | None = None
    "Optional. True, if the user is allowed to send video notes"
    can_send_voice_notes: bool | None = None
    "Optional. True, if the user is allowed to send voice notes"
    can_send_polls: bool | None = None
    "Optional. True, if the user is allowed to send polls"
    can_send_other_messages: bool | None = None
    "Optional. True, if the user is allowed to send animations, games, stickers and use inline bots"
    can_add_web_page_previews: bool | None = None
    "Optional. True, if the user is allowed to add web page previews to their messages"
    can_change_info: bool | None = None
    "Optional. True, if the user is allowed to change the chat title, photo and other settings. Ignored in public supergroups"
    can_invite_users: bool | None = None
    "Optional. True, if the user is allowed to invite new users to the chat"
    can_pin_messages: bool | None = None
    "Optional. True, if the user is allowed to pin messages. Ignored in public supergroups"
    can_manage_topics: bool | None = None
    "Optional. True, if the user is allowed to create forum topics. If omitted defaults to the value of can_pin_messages"

    def copy_with(
        self,
        can_send_messages: bool | None = None,
        can_send_audios: bool | None = None,
        can_send_documents: bool | None = None,
        can_send_photos: bool | None = None,
        can_send_videos: bool | None = None,
        can_send_video_notes: bool | None = None,
        can_send_voice_notes: bool | None = None,
        can_send_polls: bool | None = None,
        can_send_other_messages: bool | None = None,
        can_add_web_page_previews: bool | None = None,
        can_change_info: bool | None = None,
        can_invite_users: bool | None = None,
        can_pin_messages: bool | None = None,
        can_manage_topics: bool | None = None,
    ) -> ChatPermissions:
        return ChatPermissions(
            can_send_messages=self.can_send_messages
            if can_send_messages is None
            else can_send_messages,
            can_send_audios=self.can_send_audios
            if can_send_audios is None
            else can_send_audios,
            can_send_documents=self.can_send_documents
            if can_send_documents is None
            else can_send_documents,
            can_send_photos=self.can_send_photos
            if can_send_photos is None
            else can_send_photos,
            can_send_videos=self.can_send_videos
            if can_send_videos is None
            else can_send_videos,
            can_send_video_notes=self.can_send_video_notes
            if can_send_video_notes is None
            else can_send_video_notes,
            can_send_voice_notes=self.can_send_voice_notes
            if can_send_voice_notes is None
            else can_send_voice_notes,
            can_send_polls=self.can_send_polls
            if can_send_polls is None
            else can_send_polls,
            can_send_other_messages=self.can_send_other_messages
            if can_send_other_messages is None
            else can_send_other_messages,
            can_add_web_page_previews=self.can_add_web_page_previews
            if can_add_web_page_previews is None
            else can_add_web_page_previews,
            can_change_info=self.can_change_info
            if can_change_info is None
            else can_change_info,
            can_invite_users=self.can_invite_users
            if can_invite_users is None
            else can_invite_users,
            can_pin_messages=self.can_pin_messages
            if can_pin_messages is None
            else can_pin_messages,
            can_manage_topics=self.can_manage_topics
            if can_manage_topics is None
            else can_manage_topics,
        )


@dataclasses.dataclass(slots=True)
class ChatLocation:
    """Represents a location to which a chat is connected.

    More info: https://core.telegram.org/bots/api#chatlocation"""

    location: Location
    "The location to which the supergroup is connected. Can't be a live location."
    address: str
    "Location address; 1-64 characters, as defined by the chat owner"

    def copy_with(
        self,
        location: Location | None = None,
        address: str | None = None,
    ) -> ChatLocation:
        return ChatLocation(
            location=self.location if location is None else location,
            address=self.address if address is None else address,
        )


@dataclasses.dataclass(slots=True)
class ForumTopic:
    """This object represents a forum topic.

    More info: https://core.telegram.org/bots/api#forumtopic"""

    message_thread_id: int
    "Unique identifier of the forum topic"
    name: str
    "Name of the topic"
    icon_color: int
    "Color of the topic icon in RGB format"
    icon_custom_emoji_id: str | None = None
    "Optional. Unique identifier of the custom emoji shown as the topic icon"

    def copy_with(
        self,
        message_thread_id: int | None = None,
        name: str | None = None,
        icon_color: int | None = None,
        icon_custom_emoji_id: str | None = None,
    ) -> ForumTopic:
        return ForumTopic(
            message_thread_id=self.message_thread_id
            if message_thread_id is None
            else message_thread_id,
            name=self.name if name is None else name,
            icon_color=self.icon_color if icon_color is None else icon_color,
            icon_custom_emoji_id=self.icon_custom_emoji_id
            if icon_custom_emoji_id is None
            else icon_custom_emoji_id,
        )


@dataclasses.dataclass(slots=True)
class BotCommand:
    """This object represents a bot command.

    More info: https://core.telegram.org/bots/api#botcommand"""

    command: str
    "Text of the command; 1-32 characters. Can contain only lowercase English letters, digits and underscores."
    description: str
    "Description of the command; 1-256 characters."

    def copy_with(
        self,
        command: str | None = None,
        description: str | None = None,
    ) -> BotCommand:
        return BotCommand(
            command=self.command if command is None else command,
            description=self.description if description is None else description,
        )


@dataclasses.dataclass(slots=True)
class BotCommandScopeDefault:
    """Represents the default scope of bot commands. Default commands are used if no commands with a narrower scope are specified for the user.

    More info: https://core.telegram.org/bots/api#botcommandscopedefault"""

    type: str
    "Scope type, must be default"

    def copy_with(
        self,
        type: str | None = None,
    ) -> BotCommandScopeDefault:
        return BotCommandScopeDefault(type=self.type if type is None else type)


@dataclasses.dataclass(slots=True)
class BotCommandScopeAllPrivateChats:
    """Represents the scope of bot commands, covering all private chats.

    More info: https://core.telegram.org/bots/api#botcommandscopeallprivatechats"""

    type: str
    "Scope type, must be all_private_chats"

    def copy_with(
        self,
        type: str | None = None,
    ) -> BotCommandScopeAllPrivateChats:
        return BotCommandScopeAllPrivateChats(type=self.type if type is None else type)


@dataclasses.dataclass(slots=True)
class BotCommandScopeAllGroupChats:
    """Represents the scope of bot commands, covering all group and supergroup chats.

    More info: https://core.telegram.org/bots/api#botcommandscopeallgroupchats"""

    type: str
    "Scope type, must be all_group_chats"

    def copy_with(
        self,
        type: str | None = None,
    ) -> BotCommandScopeAllGroupChats:
        return BotCommandScopeAllGroupChats(type=self.type if type is None else type)


@dataclasses.dataclass(slots=True)
class BotCommandScopeAllChatAdministrators:
    """Represents the scope of bot commands, covering all group and supergroup chat administrators.

    More info: https://core.telegram.org/bots/api#botcommandscopeallchatadministrators
    """

    type: str
    "Scope type, must be all_chat_administrators"

    def copy_with(
        self,
        type: str | None = None,
    ) -> BotCommandScopeAllChatAdministrators:
        return BotCommandScopeAllChatAdministrators(
            type=self.type if type is None else type
        )


@dataclasses.dataclass(slots=True)
class BotCommandScopeChat:
    """Represents the scope of bot commands, covering a specific chat.

    More info: https://core.telegram.org/bots/api#botcommandscopechat"""

    type: str
    "Scope type, must be chat"
    chat_id: int | str
    "Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)"

    def copy_with(
        self,
        type: str | None = None,
        chat_id: int | str | None = None,
    ) -> BotCommandScopeChat:
        return BotCommandScopeChat(
            type=self.type if type is None else type,
            chat_id=self.chat_id if chat_id is None else chat_id,
        )


@dataclasses.dataclass(slots=True)
class BotCommandScopeChatAdministrators:
    """Represents the scope of bot commands, covering all administrators of a specific group or supergroup chat.

    More info: https://core.telegram.org/bots/api#botcommandscopechatadministrators"""

    type: str
    "Scope type, must be chat_administrators"
    chat_id: int | str
    "Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)"

    def copy_with(
        self,
        type: str | None = None,
        chat_id: int | str | None = None,
    ) -> BotCommandScopeChatAdministrators:
        return BotCommandScopeChatAdministrators(
            type=self.type if type is None else type,
            chat_id=self.chat_id if chat_id is None else chat_id,
        )


@dataclasses.dataclass(slots=True)
class BotCommandScopeChatMember:
    """Represents the scope of bot commands, covering a specific member of a group or supergroup chat.

    More info: https://core.telegram.org/bots/api#botcommandscopechatmember"""

    type: str
    "Scope type, must be chat_member"
    chat_id: int | str
    "Unique identifier for the target chat or username of the target supergroup (in the format @supergroupusername)"
    user_id: int
    "Unique identifier of the target user"

    def copy_with(
        self,
        type: str | None = None,
        chat_id: int | str | None = None,
        user_id: int | None = None,
    ) -> BotCommandScopeChatMember:
        return BotCommandScopeChatMember(
            type=self.type if type is None else type,
            chat_id=self.chat_id if chat_id is None else chat_id,
            user_id=self.user_id if user_id is None else user_id,
        )


@dataclasses.dataclass(slots=True)
class BotName:
    """This object represents the bot's name.

    More info: https://core.telegram.org/bots/api#botname"""

    name: str
    "The bot's name"

    def copy_with(
        self,
        name: str | None = None,
    ) -> BotName:
        return BotName(name=self.name if name is None else name)


@dataclasses.dataclass(slots=True)
class BotDescription:
    """This object represents the bot's description.

    More info: https://core.telegram.org/bots/api#botdescription"""

    description: str
    "The bot's description"

    def copy_with(
        self,
        description: str | None = None,
    ) -> BotDescription:
        return BotDescription(
            description=self.description if description is None else description
        )


@dataclasses.dataclass(slots=True)
class BotShortDescription:
    """This object represents the bot's short description.

    More info: https://core.telegram.org/bots/api#botshortdescription"""

    short_description: str
    "The bot's short description"

    def copy_with(
        self,
        short_description: str | None = None,
    ) -> BotShortDescription:
        return BotShortDescription(
            short_description=self.short_description
            if short_description is None
            else short_description
        )


@dataclasses.dataclass(slots=True)
class MenuButtonCommands:
    """Represents a menu button, which opens the bot's list of commands.

    More info: https://core.telegram.org/bots/api#menubuttoncommands"""

    type: str
    "Type of the button, must be commands"

    def copy_with(
        self,
        type: str | None = None,
    ) -> MenuButtonCommands:
        return MenuButtonCommands(type=self.type if type is None else type)


@dataclasses.dataclass(slots=True)
class MenuButtonWebApp:
    """Represents a menu button, which launches a Web App.

    More info: https://core.telegram.org/bots/api#menubuttonwebapp"""

    type: str
    "Type of the button, must be web_app"
    text: str
    "Text on the button"
    web_app: WebAppInfo
    "Description of the Web App that will be launched when the user presses the button. The Web App will be able to send an arbitrary message on behalf of the user using the method answerWebAppQuery."

    def copy_with(
        self,
        type: str | None = None,
        text: str | None = None,
        web_app: WebAppInfo | None = None,
    ) -> MenuButtonWebApp:
        return MenuButtonWebApp(
            type=self.type if type is None else type,
            text=self.text if text is None else text,
            web_app=self.web_app if web_app is None else web_app,
        )


@dataclasses.dataclass(slots=True)
class MenuButtonDefault:
    """Describes that no specific value for the menu button was set.

    More info: https://core.telegram.org/bots/api#menubuttondefault"""

    type: str
    "Type of the button, must be default"

    def copy_with(
        self,
        type: str | None = None,
    ) -> MenuButtonDefault:
        return MenuButtonDefault(type=self.type if type is None else type)


@dataclasses.dataclass(slots=True)
class ResponseParameters:
    """Describes why a request was unsuccessful.

    More info: https://core.telegram.org/bots/api#responseparameters"""

    migrate_to_chat_id: int | None = None
    "Optional. The group has been migrated to a supergroup with the specified identifier. This number may have more than 32 significant bits and some programming languages may have difficulty/silent defects in interpreting it. But it has at most 52 significant bits, so a signed 64-bit integer or double-precision float type are safe for storing this identifier."
    retry_after: int | None = None
    "Optional. In case of exceeding flood control, the number of seconds left to wait before the request can be repeated"

    def copy_with(
        self,
        migrate_to_chat_id: int | None = None,
        retry_after: int | None = None,
    ) -> ResponseParameters:
        return ResponseParameters(
            migrate_to_chat_id=self.migrate_to_chat_id
            if migrate_to_chat_id is None
            else migrate_to_chat_id,
            retry_after=self.retry_after if retry_after is None else retry_after,
        )


@dataclasses.dataclass(slots=True)
class InputMediaPhoto:
    """Represents a photo to be sent.

    More info: https://core.telegram.org/bots/api#inputmediaphoto"""

    type: str
    "Type of the result, must be photo"
    media: str
    'File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass "attach://<file_attach_name>" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files'
    caption: str | None = None
    "Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing"
    parse_mode: str | None = None
    "Optional. Mode for parsing entities in the photo caption. See formatting options for more details."
    caption_entities: list[MessageEntity] | None = None
    "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"
    has_spoiler: bool | None = None
    "Optional. Pass True if the photo needs to be covered with a spoiler animation"

    def copy_with(
        self,
        type: str | None = None,
        media: str | None = None,
        caption: str | None = None,
        parse_mode: str | None = None,
        caption_entities: list[MessageEntity] | None = None,
        has_spoiler: bool | None = None,
    ) -> InputMediaPhoto:
        return InputMediaPhoto(
            type=self.type if type is None else type,
            media=self.media if media is None else media,
            caption=self.caption if caption is None else caption,
            parse_mode=self.parse_mode if parse_mode is None else parse_mode,
            caption_entities=self.caption_entities
            if caption_entities is None
            else caption_entities,
            has_spoiler=self.has_spoiler if has_spoiler is None else has_spoiler,
        )


@dataclasses.dataclass(slots=True)
class InputMediaVideo:
    """Represents a video to be sent.

    More info: https://core.telegram.org/bots/api#inputmediavideo"""

    type: str
    "Type of the result, must be video"
    media: str
    'File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass "attach://<file_attach_name>" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files'
    thumbnail: typing.BinaryIO | str | None = None
    "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"
    caption: str | None = None
    "Optional. Caption of the video to be sent, 0-1024 characters after entities parsing"
    parse_mode: str | None = None
    "Optional. Mode for parsing entities in the video caption. See formatting options for more details."
    caption_entities: list[MessageEntity] | None = None
    "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"
    width: int | None = None
    "Optional. Video width"
    height: int | None = None
    "Optional. Video height"
    duration: int | None = None
    "Optional. Video duration in seconds"
    supports_streaming: bool | None = None
    "Optional. Pass True if the uploaded video is suitable for streaming"
    has_spoiler: bool | None = None
    "Optional. Pass True if the video needs to be covered with a spoiler animation"

    def copy_with(
        self,
        type: str | None = None,
        media: str | None = None,
        thumbnail: typing.BinaryIO | str | None = None,
        caption: str | None = None,
        parse_mode: str | None = None,
        caption_entities: list[MessageEntity] | None = None,
        width: int | None = None,
        height: int | None = None,
        duration: int | None = None,
        supports_streaming: bool | None = None,
        has_spoiler: bool | None = None,
    ) -> InputMediaVideo:
        return InputMediaVideo(
            type=self.type if type is None else type,
            media=self.media if media is None else media,
            thumbnail=self.thumbnail if thumbnail is None else thumbnail,
            caption=self.caption if caption is None else caption,
            parse_mode=self.parse_mode if parse_mode is None else parse_mode,
            caption_entities=self.caption_entities
            if caption_entities is None
            else caption_entities,
            width=self.width if width is None else width,
            height=self.height if height is None else height,
            duration=self.duration if duration is None else duration,
            supports_streaming=self.supports_streaming
            if supports_streaming is None
            else supports_streaming,
            has_spoiler=self.has_spoiler if has_spoiler is None else has_spoiler,
        )


@dataclasses.dataclass(slots=True)
class InputMediaAnimation:
    """Represents an animation file (GIF or H.264/MPEG-4 AVC video without sound) to be sent.

    More info: https://core.telegram.org/bots/api#inputmediaanimation"""

    type: str
    "Type of the result, must be animation"
    media: str
    'File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass "attach://<file_attach_name>" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files'
    thumbnail: typing.BinaryIO | str | None = None
    "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"
    caption: str | None = None
    "Optional. Caption of the animation to be sent, 0-1024 characters after entities parsing"
    parse_mode: str | None = None
    "Optional. Mode for parsing entities in the animation caption. See formatting options for more details."
    caption_entities: list[MessageEntity] | None = None
    "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"
    width: int | None = None
    "Optional. Animation width"
    height: int | None = None
    "Optional. Animation height"
    duration: int | None = None
    "Optional. Animation duration in seconds"
    has_spoiler: bool | None = None
    "Optional. Pass True if the animation needs to be covered with a spoiler animation"

    def copy_with(
        self,
        type: str | None = None,
        media: str | None = None,
        thumbnail: typing.BinaryIO | str | None = None,
        caption: str | None = None,
        parse_mode: str | None = None,
        caption_entities: list[MessageEntity] | None = None,
        width: int | None = None,
        height: int | None = None,
        duration: int | None = None,
        has_spoiler: bool | None = None,
    ) -> InputMediaAnimation:
        return InputMediaAnimation(
            type=self.type if type is None else type,
            media=self.media if media is None else media,
            thumbnail=self.thumbnail if thumbnail is None else thumbnail,
            caption=self.caption if caption is None else caption,
            parse_mode=self.parse_mode if parse_mode is None else parse_mode,
            caption_entities=self.caption_entities
            if caption_entities is None
            else caption_entities,
            width=self.width if width is None else width,
            height=self.height if height is None else height,
            duration=self.duration if duration is None else duration,
            has_spoiler=self.has_spoiler if has_spoiler is None else has_spoiler,
        )


@dataclasses.dataclass(slots=True)
class InputMediaAudio:
    """Represents an audio file to be treated as music to be sent.

    More info: https://core.telegram.org/bots/api#inputmediaaudio"""

    type: str
    "Type of the result, must be audio"
    media: str
    'File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass "attach://<file_attach_name>" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files'
    thumbnail: typing.BinaryIO | str | None = None
    "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"
    caption: str | None = None
    "Optional. Caption of the audio to be sent, 0-1024 characters after entities parsing"
    parse_mode: str | None = None
    "Optional. Mode for parsing entities in the audio caption. See formatting options for more details."
    caption_entities: list[MessageEntity] | None = None
    "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"
    duration: int | None = None
    "Optional. Duration of the audio in seconds"
    performer: str | None = None
    "Optional. Performer of the audio"
    title: str | None = None
    "Optional. Title of the audio"

    def copy_with(
        self,
        type: str | None = None,
        media: str | None = None,
        thumbnail: typing.BinaryIO | str | None = None,
        caption: str | None = None,
        parse_mode: str | None = None,
        caption_entities: list[MessageEntity] | None = None,
        duration: int | None = None,
        performer: str | None = None,
        title: str | None = None,
    ) -> InputMediaAudio:
        return InputMediaAudio(
            type=self.type if type is None else type,
            media=self.media if media is None else media,
            thumbnail=self.thumbnail if thumbnail is None else thumbnail,
            caption=self.caption if caption is None else caption,
            parse_mode=self.parse_mode if parse_mode is None else parse_mode,
            caption_entities=self.caption_entities
            if caption_entities is None
            else caption_entities,
            duration=self.duration if duration is None else duration,
            performer=self.performer if performer is None else performer,
            title=self.title if title is None else title,
        )


@dataclasses.dataclass(slots=True)
class InputMediaDocument:
    """Represents a general file to be sent.

    More info: https://core.telegram.org/bots/api#inputmediadocument"""

    type: str
    "Type of the result, must be document"
    media: str
    'File to send. Pass a file_id to send a file that exists on the Telegram servers (recommended), pass an HTTP URL for Telegram to get a file from the Internet, or pass "attach://<file_attach_name>" to upload a new one using multipart/form-data under <file_attach_name> name. More information on Sending Files: https://core.telegram.org/bots/api#sending-files'
    thumbnail: typing.BinaryIO | str | None = None
    "Optional. Thumbnail of the file sent; can be ignored if thumbnail generation for the file is supported server-side. The thumbnail should be in JPEG format and less than 200 kB in size. A thumbnail's width and height should not exceed 320. Ignored if the file is not uploaded using multipart/form-data. Thumbnails can't be reused and can be only uploaded as a new file, so you can pass \"attach://<file_attach_name>\" if the thumbnail was uploaded using multipart/form-data under <file_attach_name>. More information on Sending Files: https://core.telegram.org/bots/api#sending-files"
    caption: str | None = None
    "Optional. Caption of the document to be sent, 0-1024 characters after entities parsing"
    parse_mode: str | None = None
    "Optional. Mode for parsing entities in the document caption. See formatting options for more details."
    caption_entities: list[MessageEntity] | None = None
    "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"
    disable_content_type_detection: bool | None = None
    "Optional. Disables automatic server-side content type detection for files uploaded using multipart/form-data. Always True, if the document is sent as part of an album."

    def copy_with(
        self,
        type: str | None = None,
        media: str | None = None,
        thumbnail: typing.BinaryIO | str | None = None,
        caption: str | None = None,
        parse_mode: str | None = None,
        caption_entities: list[MessageEntity] | None = None,
        disable_content_type_detection: bool | None = None,
    ) -> InputMediaDocument:
        return InputMediaDocument(
            type=self.type if type is None else type,
            media=self.media if media is None else media,
            thumbnail=self.thumbnail if thumbnail is None else thumbnail,
            caption=self.caption if caption is None else caption,
            parse_mode=self.parse_mode if parse_mode is None else parse_mode,
            caption_entities=self.caption_entities
            if caption_entities is None
            else caption_entities,
            disable_content_type_detection=self.disable_content_type_detection
            if disable_content_type_detection is None
            else disable_content_type_detection,
        )


@dataclasses.dataclass(slots=True)
class Sticker:
    """This object represents a sticker.

    More info: https://core.telegram.org/bots/api#sticker"""

    file_id: str
    "Identifier for this file, which can be used to download or reuse the file"
    file_unique_id: str
    "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."
    type: str
    'Type of the sticker, currently one of "regular", "mask", "custom_emoji". The type of the sticker is independent from its format, which is determined by the fields is_animated and is_video.'
    width: int
    "Sticker width"
    height: int
    "Sticker height"
    is_animated: bool
    "True, if the sticker is animated"
    is_video: bool
    "True, if the sticker is a video sticker"
    thumbnail: PhotoSize | None = None
    "Optional. Sticker thumbnail in the .WEBP or .JPG format"
    emoji: str | None = None
    "Optional. Emoji associated with the sticker"
    set_name: str | None = None
    "Optional. Name of the sticker set to which the sticker belongs"
    premium_animation: File | None = None
    "Optional. For premium regular stickers, premium animation for the sticker"
    mask_position: MaskPosition | None = None
    "Optional. For mask stickers, the position where the mask should be placed"
    custom_emoji_id: str | None = None
    "Optional. For custom emoji stickers, unique identifier of the custom emoji"
    needs_repainting: bool | None = None
    "Optional. True, if the sticker must be repainted to a text color in messages, the color of the Telegram Premium badge in emoji status, white color on chat photos, or another appropriate color in other places"
    file_size: int | None = None
    "Optional. File size in bytes"

    def copy_with(
        self,
        file_id: str | None = None,
        file_unique_id: str | None = None,
        type: str | None = None,
        width: int | None = None,
        height: int | None = None,
        is_animated: bool | None = None,
        is_video: bool | None = None,
        thumbnail: PhotoSize | None = None,
        emoji: str | None = None,
        set_name: str | None = None,
        premium_animation: File | None = None,
        mask_position: MaskPosition | None = None,
        custom_emoji_id: str | None = None,
        needs_repainting: bool | None = None,
        file_size: int | None = None,
    ) -> Sticker:
        return Sticker(
            file_id=self.file_id if file_id is None else file_id,
            file_unique_id=self.file_unique_id
            if file_unique_id is None
            else file_unique_id,
            type=self.type if type is None else type,
            width=self.width if width is None else width,
            height=self.height if height is None else height,
            is_animated=self.is_animated if is_animated is None else is_animated,
            is_video=self.is_video if is_video is None else is_video,
            thumbnail=self.thumbnail if thumbnail is None else thumbnail,
            emoji=self.emoji if emoji is None else emoji,
            set_name=self.set_name if set_name is None else set_name,
            premium_animation=self.premium_animation
            if premium_animation is None
            else premium_animation,
            mask_position=self.mask_position
            if mask_position is None
            else mask_position,
            custom_emoji_id=self.custom_emoji_id
            if custom_emoji_id is None
            else custom_emoji_id,
            needs_repainting=self.needs_repainting
            if needs_repainting is None
            else needs_repainting,
            file_size=self.file_size if file_size is None else file_size,
        )


@dataclasses.dataclass(slots=True)
class StickerSet:
    """This object represents a sticker set.

    More info: https://core.telegram.org/bots/api#stickerset"""

    name: str
    "Sticker set name"
    title: str
    "Sticker set title"
    sticker_type: str
    'Type of stickers in the set, currently one of "regular", "mask", "custom_emoji"'
    is_animated: bool
    "True, if the sticker set contains animated stickers"
    is_video: bool
    "True, if the sticker set contains video stickers"
    stickers: list[Sticker]
    "List of all set stickers"
    thumbnail: PhotoSize | None = None
    "Optional. Sticker set thumbnail in the .WEBP, .TGS, or .WEBM format"

    def copy_with(
        self,
        name: str | None = None,
        title: str | None = None,
        sticker_type: str | None = None,
        is_animated: bool | None = None,
        is_video: bool | None = None,
        stickers: list[Sticker] | None = None,
        thumbnail: PhotoSize | None = None,
    ) -> StickerSet:
        return StickerSet(
            name=self.name if name is None else name,
            title=self.title if title is None else title,
            sticker_type=self.sticker_type if sticker_type is None else sticker_type,
            is_animated=self.is_animated if is_animated is None else is_animated,
            is_video=self.is_video if is_video is None else is_video,
            stickers=self.stickers if stickers is None else stickers,
            thumbnail=self.thumbnail if thumbnail is None else thumbnail,
        )


@dataclasses.dataclass(slots=True)
class MaskPosition:
    """This object describes the position on faces where a mask should be placed by default.

    More info: https://core.telegram.org/bots/api#maskposition"""

    point: str
    'The part of the face relative to which the mask should be placed. One of "forehead", "eyes", "mouth", or "chin".'
    x_shift: float
    "Shift by X-axis measured in widths of the mask scaled to the face size, from left to right. For example, choosing -1.0 will place mask just to the left of the default mask position."
    y_shift: float
    "Shift by Y-axis measured in heights of the mask scaled to the face size, from top to bottom. For example, 1.0 will place the mask just below the default mask position."
    scale: float
    "Mask scaling coefficient. For example, 2.0 means double size."

    def copy_with(
        self,
        point: str | None = None,
        x_shift: float | None = None,
        y_shift: float | None = None,
        scale: float | None = None,
    ) -> MaskPosition:
        return MaskPosition(
            point=self.point if point is None else point,
            x_shift=self.x_shift if x_shift is None else x_shift,
            y_shift=self.y_shift if y_shift is None else y_shift,
            scale=self.scale if scale is None else scale,
        )


@dataclasses.dataclass(slots=True)
class InputSticker:
    """This object describes a sticker to be added to a sticker set.

    More info: https://core.telegram.org/bots/api#inputsticker"""

    sticker: typing.BinaryIO | str
    'The added sticker. Pass a file_id as a String to send a file that already exists on the Telegram servers, pass an HTTP URL as a String for Telegram to get a file from the Internet, upload a new one using multipart/form-data, or pass "attach://<file_attach_name>" to upload a new one using multipart/form-data under <file_attach_name> name. Animated and video stickers can\'t be uploaded via HTTP URL. More information on Sending Files: https://core.telegram.org/bots/api#sending-files'
    emoji_list: list[str]
    "List of 1-20 emoji associated with the sticker"
    mask_position: MaskPosition | None = None
    'Optional. Position where the mask should be placed on faces. For "mask" stickers only.'
    keywords: list[str] | None = None
    'Optional. List of 0-20 search keywords for the sticker with total length of up to 64 characters. For "regular" and "custom_emoji" stickers only.'

    def copy_with(
        self,
        sticker: typing.BinaryIO | str | None = None,
        emoji_list: list[str] | None = None,
        mask_position: MaskPosition | None = None,
        keywords: list[str] | None = None,
    ) -> InputSticker:
        return InputSticker(
            sticker=self.sticker if sticker is None else sticker,
            emoji_list=self.emoji_list if emoji_list is None else emoji_list,
            mask_position=self.mask_position
            if mask_position is None
            else mask_position,
            keywords=self.keywords if keywords is None else keywords,
        )


@dataclasses.dataclass(slots=True)
class InlineQuery:
    """This object represents an incoming inline query. When the user sends an empty query, your bot could return some default or trending results.

    More info: https://core.telegram.org/bots/api#inlinequery"""

    id: str
    "Unique identifier for this query"
    from_: User
    "Sender"
    query: str
    "Text of the query (up to 256 characters)"
    offset: str
    "Offset of the results to be returned, can be controlled by the bot"
    chat_type: str | None = None
    'Optional. Type of the chat from which the inline query was sent. Can be either "sender" for a private chat with the inline query sender, "private", "group", "supergroup", or "channel". The chat type should be always known for requests sent from official clients and most third-party clients, unless the request was sent from a secret chat'
    location: Location | None = None
    "Optional. Sender location, only for bots that request user location"

    def copy_with(
        self,
        id: str | None = None,
        from_: User | None = None,
        query: str | None = None,
        offset: str | None = None,
        chat_type: str | None = None,
        location: Location | None = None,
    ) -> InlineQuery:
        return InlineQuery(
            id=self.id if id is None else id,
            from_=self.from_ if from_ is None else from_,
            query=self.query if query is None else query,
            offset=self.offset if offset is None else offset,
            chat_type=self.chat_type if chat_type is None else chat_type,
            location=self.location if location is None else location,
        )


@dataclasses.dataclass(slots=True)
class InlineQueryResultsButton:
    """This object represents a button to be shown above inline query results. You must use exactly one of the optional fields.

    More info: https://core.telegram.org/bots/api#inlinequeryresultsbutton"""

    text: str
    "Label text on the button"
    web_app: WebAppInfo | None = None
    "Optional. Description of the Web App that will be launched when the user presses the button. The Web App will be able to switch back to the inline mode using the method switchInlineQuery inside the Web App."
    start_parameter: str | None = None
    "Optional. Deep-linking parameter for the /start message sent to the bot when a user presses the button. 1-64 characters, only A-Z, a-z, 0-9, _ and - are allowed. Example: An inline bot that sends YouTube videos can ask the user to connect the bot to their YouTube account to adapt search results accordingly. To do this, it displays a 'Connect your YouTube account' button above the results, or even before showing any. The user presses the button, switches to a private chat with the bot and, in doing so, passes a start parameter that instructs the bot to return an OAuth link. Once done, the bot can offer a switch_inline button so that the user can easily return to the chat where they wanted to use the bot's inline capabilities."

    def copy_with(
        self,
        text: str | None = None,
        web_app: WebAppInfo | None = None,
        start_parameter: str | None = None,
    ) -> InlineQueryResultsButton:
        return InlineQueryResultsButton(
            text=self.text if text is None else text,
            web_app=self.web_app if web_app is None else web_app,
            start_parameter=self.start_parameter
            if start_parameter is None
            else start_parameter,
        )


@dataclasses.dataclass(slots=True)
class InlineQueryResultArticle:
    """Represents a link to an article or web page.

    More info: https://core.telegram.org/bots/api#inlinequeryresultarticle"""

    type: str
    "Type of the result, must be article"
    id: str
    "Unique identifier for this result, 1-64 Bytes"
    title: str
    "Title of the result"
    input_message_content: InputMessageContent
    "Content of the message to be sent"
    reply_markup: InlineKeyboardMarkup | None = None
    "Optional. Inline keyboard attached to the message"
    url: str | None = None
    "Optional. URL of the result"
    hide_url: bool | None = None
    "Optional. Pass True if you don't want the URL to be shown in the message"
    description: str | None = None
    "Optional. Short description of the result"
    thumbnail_url: str | None = None
    "Optional. Url of the thumbnail for the result"
    thumbnail_width: int | None = None
    "Optional. Thumbnail width"
    thumbnail_height: int | None = None
    "Optional. Thumbnail height"

    def copy_with(
        self,
        type: str | None = None,
        id: str | None = None,
        title: str | None = None,
        input_message_content: InputMessageContent | None = None,
        reply_markup: InlineKeyboardMarkup | None = None,
        url: str | None = None,
        hide_url: bool | None = None,
        description: str | None = None,
        thumbnail_url: str | None = None,
        thumbnail_width: int | None = None,
        thumbnail_height: int | None = None,
    ) -> InlineQueryResultArticle:
        return InlineQueryResultArticle(
            type=self.type if type is None else type,
            id=self.id if id is None else id,
            title=self.title if title is None else title,
            input_message_content=self.input_message_content
            if input_message_content is None
            else input_message_content,
            reply_markup=self.reply_markup if reply_markup is None else reply_markup,
            url=self.url if url is None else url,
            hide_url=self.hide_url if hide_url is None else hide_url,
            description=self.description if description is None else description,
            thumbnail_url=self.thumbnail_url
            if thumbnail_url is None
            else thumbnail_url,
            thumbnail_width=self.thumbnail_width
            if thumbnail_width is None
            else thumbnail_width,
            thumbnail_height=self.thumbnail_height
            if thumbnail_height is None
            else thumbnail_height,
        )


@dataclasses.dataclass(slots=True)
class InlineQueryResultPhoto:
    """Represents a link to a photo. By default, this photo will be sent by the user with optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the photo.

    More info: https://core.telegram.org/bots/api#inlinequeryresultphoto"""

    type: str
    "Type of the result, must be photo"
    id: str
    "Unique identifier for this result, 1-64 bytes"
    photo_url: str
    "A valid URL of the photo. Photo must be in JPEG format. Photo size must not exceed 5MB"
    thumbnail_url: str
    "URL of the thumbnail for the photo"
    photo_width: int | None = None
    "Optional. Width of the photo"
    photo_height: int | None = None
    "Optional. Height of the photo"
    title: str | None = None
    "Optional. Title for the result"
    description: str | None = None
    "Optional. Short description of the result"
    caption: str | None = None
    "Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing"
    parse_mode: str | None = None
    "Optional. Mode for parsing entities in the photo caption. See formatting options for more details."
    caption_entities: list[MessageEntity] | None = None
    "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"
    reply_markup: InlineKeyboardMarkup | None = None
    "Optional. Inline keyboard attached to the message"
    input_message_content: InputMessageContent | None = None
    "Optional. Content of the message to be sent instead of the photo"

    def copy_with(
        self,
        type: str | None = None,
        id: str | None = None,
        photo_url: str | None = None,
        thumbnail_url: str | None = None,
        photo_width: int | None = None,
        photo_height: int | None = None,
        title: str | None = None,
        description: str | None = None,
        caption: str | None = None,
        parse_mode: str | None = None,
        caption_entities: list[MessageEntity] | None = None,
        reply_markup: InlineKeyboardMarkup | None = None,
        input_message_content: InputMessageContent | None = None,
    ) -> InlineQueryResultPhoto:
        return InlineQueryResultPhoto(
            type=self.type if type is None else type,
            id=self.id if id is None else id,
            photo_url=self.photo_url if photo_url is None else photo_url,
            thumbnail_url=self.thumbnail_url
            if thumbnail_url is None
            else thumbnail_url,
            photo_width=self.photo_width if photo_width is None else photo_width,
            photo_height=self.photo_height if photo_height is None else photo_height,
            title=self.title if title is None else title,
            description=self.description if description is None else description,
            caption=self.caption if caption is None else caption,
            parse_mode=self.parse_mode if parse_mode is None else parse_mode,
            caption_entities=self.caption_entities
            if caption_entities is None
            else caption_entities,
            reply_markup=self.reply_markup if reply_markup is None else reply_markup,
            input_message_content=self.input_message_content
            if input_message_content is None
            else input_message_content,
        )


@dataclasses.dataclass(slots=True)
class InlineQueryResultGif:
    """Represents a link to an animated GIF file. By default, this animated GIF file will be sent by the user with optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the animation.

    More info: https://core.telegram.org/bots/api#inlinequeryresultgif"""

    type: str
    "Type of the result, must be gif"
    id: str
    "Unique identifier for this result, 1-64 bytes"
    gif_url: str
    "A valid URL for the GIF file. File size must not exceed 1MB"
    thumbnail_url: str
    "URL of the static (JPEG or GIF) or animated (MPEG4) thumbnail for the result"
    gif_width: int | None = None
    "Optional. Width of the GIF"
    gif_height: int | None = None
    "Optional. Height of the GIF"
    gif_duration: int | None = None
    "Optional. Duration of the GIF in seconds"
    thumbnail_mime_type: str | None = None
    'Optional. MIME type of the thumbnail, must be one of "image/jpeg", "image/gif", or "video/mp4". Defaults to "image/jpeg"'
    title: str | None = None
    "Optional. Title for the result"
    caption: str | None = None
    "Optional. Caption of the GIF file to be sent, 0-1024 characters after entities parsing"
    parse_mode: str | None = None
    "Optional. Mode for parsing entities in the caption. See formatting options for more details."
    caption_entities: list[MessageEntity] | None = None
    "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"
    reply_markup: InlineKeyboardMarkup | None = None
    "Optional. Inline keyboard attached to the message"
    input_message_content: InputMessageContent | None = None
    "Optional. Content of the message to be sent instead of the GIF animation"

    def copy_with(
        self,
        type: str | None = None,
        id: str | None = None,
        gif_url: str | None = None,
        gif_width: int | None = None,
        gif_height: int | None = None,
        gif_duration: int | None = None,
        thumbnail_url: str | None = None,
        thumbnail_mime_type: str | None = None,
        title: str | None = None,
        caption: str | None = None,
        parse_mode: str | None = None,
        caption_entities: list[MessageEntity] | None = None,
        reply_markup: InlineKeyboardMarkup | None = None,
        input_message_content: InputMessageContent | None = None,
    ) -> InlineQueryResultGif:
        return InlineQueryResultGif(
            type=self.type if type is None else type,
            id=self.id if id is None else id,
            gif_url=self.gif_url if gif_url is None else gif_url,
            gif_width=self.gif_width if gif_width is None else gif_width,
            gif_height=self.gif_height if gif_height is None else gif_height,
            gif_duration=self.gif_duration if gif_duration is None else gif_duration,
            thumbnail_url=self.thumbnail_url
            if thumbnail_url is None
            else thumbnail_url,
            thumbnail_mime_type=self.thumbnail_mime_type
            if thumbnail_mime_type is None
            else thumbnail_mime_type,
            title=self.title if title is None else title,
            caption=self.caption if caption is None else caption,
            parse_mode=self.parse_mode if parse_mode is None else parse_mode,
            caption_entities=self.caption_entities
            if caption_entities is None
            else caption_entities,
            reply_markup=self.reply_markup if reply_markup is None else reply_markup,
            input_message_content=self.input_message_content
            if input_message_content is None
            else input_message_content,
        )


@dataclasses.dataclass(slots=True)
class InlineQueryResultMpeg4Gif:
    """Represents a link to a video animation (H.264/MPEG-4 AVC video without sound). By default, this animated MPEG-4 file will be sent by the user with optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the animation.

    More info: https://core.telegram.org/bots/api#inlinequeryresultmpeg4gif"""

    type: str
    "Type of the result, must be mpeg4_gif"
    id: str
    "Unique identifier for this result, 1-64 bytes"
    mpeg4_url: str
    "A valid URL for the MPEG4 file. File size must not exceed 1MB"
    thumbnail_url: str
    "URL of the static (JPEG or GIF) or animated (MPEG4) thumbnail for the result"
    mpeg4_width: int | None = None
    "Optional. Video width"
    mpeg4_height: int | None = None
    "Optional. Video height"
    mpeg4_duration: int | None = None
    "Optional. Video duration in seconds"
    thumbnail_mime_type: str | None = None
    'Optional. MIME type of the thumbnail, must be one of "image/jpeg", "image/gif", or "video/mp4". Defaults to "image/jpeg"'
    title: str | None = None
    "Optional. Title for the result"
    caption: str | None = None
    "Optional. Caption of the MPEG-4 file to be sent, 0-1024 characters after entities parsing"
    parse_mode: str | None = None
    "Optional. Mode for parsing entities in the caption. See formatting options for more details."
    caption_entities: list[MessageEntity] | None = None
    "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"
    reply_markup: InlineKeyboardMarkup | None = None
    "Optional. Inline keyboard attached to the message"
    input_message_content: InputMessageContent | None = None
    "Optional. Content of the message to be sent instead of the video animation"

    def copy_with(
        self,
        type: str | None = None,
        id: str | None = None,
        mpeg4_url: str | None = None,
        mpeg4_width: int | None = None,
        mpeg4_height: int | None = None,
        mpeg4_duration: int | None = None,
        thumbnail_url: str | None = None,
        thumbnail_mime_type: str | None = None,
        title: str | None = None,
        caption: str | None = None,
        parse_mode: str | None = None,
        caption_entities: list[MessageEntity] | None = None,
        reply_markup: InlineKeyboardMarkup | None = None,
        input_message_content: InputMessageContent | None = None,
    ) -> InlineQueryResultMpeg4Gif:
        return InlineQueryResultMpeg4Gif(
            type=self.type if type is None else type,
            id=self.id if id is None else id,
            mpeg4_url=self.mpeg4_url if mpeg4_url is None else mpeg4_url,
            mpeg4_width=self.mpeg4_width if mpeg4_width is None else mpeg4_width,
            mpeg4_height=self.mpeg4_height if mpeg4_height is None else mpeg4_height,
            mpeg4_duration=self.mpeg4_duration
            if mpeg4_duration is None
            else mpeg4_duration,
            thumbnail_url=self.thumbnail_url
            if thumbnail_url is None
            else thumbnail_url,
            thumbnail_mime_type=self.thumbnail_mime_type
            if thumbnail_mime_type is None
            else thumbnail_mime_type,
            title=self.title if title is None else title,
            caption=self.caption if caption is None else caption,
            parse_mode=self.parse_mode if parse_mode is None else parse_mode,
            caption_entities=self.caption_entities
            if caption_entities is None
            else caption_entities,
            reply_markup=self.reply_markup if reply_markup is None else reply_markup,
            input_message_content=self.input_message_content
            if input_message_content is None
            else input_message_content,
        )


@dataclasses.dataclass(slots=True)
class InlineQueryResultVideo:
    """Represents a link to a page containing an embedded video player or a video file. By default, this video file will be sent by the user with an optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the video.

    More info: https://core.telegram.org/bots/api#inlinequeryresultvideo"""

    type: str
    "Type of the result, must be video"
    id: str
    "Unique identifier for this result, 1-64 bytes"
    video_url: str
    "A valid URL for the embedded video player or video file"
    mime_type: str
    'MIME type of the content of the video URL, "text/html" or "video/mp4"'
    thumbnail_url: str
    "URL of the thumbnail (JPEG only) for the video"
    title: str
    "Title for the result"
    caption: str | None = None
    "Optional. Caption of the video to be sent, 0-1024 characters after entities parsing"
    parse_mode: str | None = None
    "Optional. Mode for parsing entities in the video caption. See formatting options for more details."
    caption_entities: list[MessageEntity] | None = None
    "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"
    video_width: int | None = None
    "Optional. Video width"
    video_height: int | None = None
    "Optional. Video height"
    video_duration: int | None = None
    "Optional. Video duration in seconds"
    description: str | None = None
    "Optional. Short description of the result"
    reply_markup: InlineKeyboardMarkup | None = None
    "Optional. Inline keyboard attached to the message"
    input_message_content: InputMessageContent | None = None
    "Optional. Content of the message to be sent instead of the video. This field is required if InlineQueryResultVideo is used to send an HTML-page as a result (e.g., a YouTube video)."

    def copy_with(
        self,
        type: str | None = None,
        id: str | None = None,
        video_url: str | None = None,
        mime_type: str | None = None,
        thumbnail_url: str | None = None,
        title: str | None = None,
        caption: str | None = None,
        parse_mode: str | None = None,
        caption_entities: list[MessageEntity] | None = None,
        video_width: int | None = None,
        video_height: int | None = None,
        video_duration: int | None = None,
        description: str | None = None,
        reply_markup: InlineKeyboardMarkup | None = None,
        input_message_content: InputMessageContent | None = None,
    ) -> InlineQueryResultVideo:
        return InlineQueryResultVideo(
            type=self.type if type is None else type,
            id=self.id if id is None else id,
            video_url=self.video_url if video_url is None else video_url,
            mime_type=self.mime_type if mime_type is None else mime_type,
            thumbnail_url=self.thumbnail_url
            if thumbnail_url is None
            else thumbnail_url,
            title=self.title if title is None else title,
            caption=self.caption if caption is None else caption,
            parse_mode=self.parse_mode if parse_mode is None else parse_mode,
            caption_entities=self.caption_entities
            if caption_entities is None
            else caption_entities,
            video_width=self.video_width if video_width is None else video_width,
            video_height=self.video_height if video_height is None else video_height,
            video_duration=self.video_duration
            if video_duration is None
            else video_duration,
            description=self.description if description is None else description,
            reply_markup=self.reply_markup if reply_markup is None else reply_markup,
            input_message_content=self.input_message_content
            if input_message_content is None
            else input_message_content,
        )


@dataclasses.dataclass(slots=True)
class InlineQueryResultAudio:
    """Represents a link to an MP3 audio file. By default, this audio file will be sent by the user. Alternatively, you can use input_message_content to send a message with the specified content instead of the audio.
    Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them.

    More info: https://core.telegram.org/bots/api#inlinequeryresultaudio"""

    type: str
    "Type of the result, must be audio"
    id: str
    "Unique identifier for this result, 1-64 bytes"
    audio_url: str
    "A valid URL for the audio file"
    title: str
    "Title"
    caption: str | None = None
    "Optional. Caption, 0-1024 characters after entities parsing"
    parse_mode: str | None = None
    "Optional. Mode for parsing entities in the audio caption. See formatting options for more details."
    caption_entities: list[MessageEntity] | None = None
    "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"
    performer: str | None = None
    "Optional. Performer"
    audio_duration: int | None = None
    "Optional. Audio duration in seconds"
    reply_markup: InlineKeyboardMarkup | None = None
    "Optional. Inline keyboard attached to the message"
    input_message_content: InputMessageContent | None = None
    "Optional. Content of the message to be sent instead of the audio"

    def copy_with(
        self,
        type: str | None = None,
        id: str | None = None,
        audio_url: str | None = None,
        title: str | None = None,
        caption: str | None = None,
        parse_mode: str | None = None,
        caption_entities: list[MessageEntity] | None = None,
        performer: str | None = None,
        audio_duration: int | None = None,
        reply_markup: InlineKeyboardMarkup | None = None,
        input_message_content: InputMessageContent | None = None,
    ) -> InlineQueryResultAudio:
        return InlineQueryResultAudio(
            type=self.type if type is None else type,
            id=self.id if id is None else id,
            audio_url=self.audio_url if audio_url is None else audio_url,
            title=self.title if title is None else title,
            caption=self.caption if caption is None else caption,
            parse_mode=self.parse_mode if parse_mode is None else parse_mode,
            caption_entities=self.caption_entities
            if caption_entities is None
            else caption_entities,
            performer=self.performer if performer is None else performer,
            audio_duration=self.audio_duration
            if audio_duration is None
            else audio_duration,
            reply_markup=self.reply_markup if reply_markup is None else reply_markup,
            input_message_content=self.input_message_content
            if input_message_content is None
            else input_message_content,
        )


@dataclasses.dataclass(slots=True)
class InlineQueryResultVoice:
    """Represents a link to a voice recording in an .OGG container encoded with OPUS. By default, this voice recording will be sent by the user. Alternatively, you can use input_message_content to send a message with the specified content instead of the the voice message.
    Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them.

    More info: https://core.telegram.org/bots/api#inlinequeryresultvoice"""

    type: str
    "Type of the result, must be voice"
    id: str
    "Unique identifier for this result, 1-64 bytes"
    voice_url: str
    "A valid URL for the voice recording"
    title: str
    "Recording title"
    caption: str | None = None
    "Optional. Caption, 0-1024 characters after entities parsing"
    parse_mode: str | None = None
    "Optional. Mode for parsing entities in the voice message caption. See formatting options for more details."
    caption_entities: list[MessageEntity] | None = None
    "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"
    voice_duration: int | None = None
    "Optional. Recording duration in seconds"
    reply_markup: InlineKeyboardMarkup | None = None
    "Optional. Inline keyboard attached to the message"
    input_message_content: InputMessageContent | None = None
    "Optional. Content of the message to be sent instead of the voice recording"

    def copy_with(
        self,
        type: str | None = None,
        id: str | None = None,
        voice_url: str | None = None,
        title: str | None = None,
        caption: str | None = None,
        parse_mode: str | None = None,
        caption_entities: list[MessageEntity] | None = None,
        voice_duration: int | None = None,
        reply_markup: InlineKeyboardMarkup | None = None,
        input_message_content: InputMessageContent | None = None,
    ) -> InlineQueryResultVoice:
        return InlineQueryResultVoice(
            type=self.type if type is None else type,
            id=self.id if id is None else id,
            voice_url=self.voice_url if voice_url is None else voice_url,
            title=self.title if title is None else title,
            caption=self.caption if caption is None else caption,
            parse_mode=self.parse_mode if parse_mode is None else parse_mode,
            caption_entities=self.caption_entities
            if caption_entities is None
            else caption_entities,
            voice_duration=self.voice_duration
            if voice_duration is None
            else voice_duration,
            reply_markup=self.reply_markup if reply_markup is None else reply_markup,
            input_message_content=self.input_message_content
            if input_message_content is None
            else input_message_content,
        )


@dataclasses.dataclass(slots=True)
class InlineQueryResultDocument:
    """Represents a link to a file. By default, this file will be sent by the user with an optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the file. Currently, only .PDF and .ZIP files can be sent using this method.
    Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them.

    More info: https://core.telegram.org/bots/api#inlinequeryresultdocument"""

    type: str
    "Type of the result, must be document"
    id: str
    "Unique identifier for this result, 1-64 bytes"
    title: str
    "Title for the result"
    document_url: str
    "A valid URL for the file"
    mime_type: str
    'MIME type of the content of the file, either "application/pdf" or "application/zip"'
    caption: str | None = None
    "Optional. Caption of the document to be sent, 0-1024 characters after entities parsing"
    parse_mode: str | None = None
    "Optional. Mode for parsing entities in the document caption. See formatting options for more details."
    caption_entities: list[MessageEntity] | None = None
    "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"
    description: str | None = None
    "Optional. Short description of the result"
    reply_markup: InlineKeyboardMarkup | None = None
    "Optional. Inline keyboard attached to the message"
    input_message_content: InputMessageContent | None = None
    "Optional. Content of the message to be sent instead of the file"
    thumbnail_url: str | None = None
    "Optional. URL of the thumbnail (JPEG only) for the file"
    thumbnail_width: int | None = None
    "Optional. Thumbnail width"
    thumbnail_height: int | None = None
    "Optional. Thumbnail height"

    def copy_with(
        self,
        type: str | None = None,
        id: str | None = None,
        title: str | None = None,
        caption: str | None = None,
        parse_mode: str | None = None,
        caption_entities: list[MessageEntity] | None = None,
        document_url: str | None = None,
        mime_type: str | None = None,
        description: str | None = None,
        reply_markup: InlineKeyboardMarkup | None = None,
        input_message_content: InputMessageContent | None = None,
        thumbnail_url: str | None = None,
        thumbnail_width: int | None = None,
        thumbnail_height: int | None = None,
    ) -> InlineQueryResultDocument:
        return InlineQueryResultDocument(
            type=self.type if type is None else type,
            id=self.id if id is None else id,
            title=self.title if title is None else title,
            caption=self.caption if caption is None else caption,
            parse_mode=self.parse_mode if parse_mode is None else parse_mode,
            caption_entities=self.caption_entities
            if caption_entities is None
            else caption_entities,
            document_url=self.document_url if document_url is None else document_url,
            mime_type=self.mime_type if mime_type is None else mime_type,
            description=self.description if description is None else description,
            reply_markup=self.reply_markup if reply_markup is None else reply_markup,
            input_message_content=self.input_message_content
            if input_message_content is None
            else input_message_content,
            thumbnail_url=self.thumbnail_url
            if thumbnail_url is None
            else thumbnail_url,
            thumbnail_width=self.thumbnail_width
            if thumbnail_width is None
            else thumbnail_width,
            thumbnail_height=self.thumbnail_height
            if thumbnail_height is None
            else thumbnail_height,
        )


@dataclasses.dataclass(slots=True)
class InlineQueryResultLocation:
    """Represents a location on a map. By default, the location will be sent by the user. Alternatively, you can use input_message_content to send a message with the specified content instead of the location.
    Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them.

    More info: https://core.telegram.org/bots/api#inlinequeryresultlocation"""

    type: str
    "Type of the result, must be location"
    id: str
    "Unique identifier for this result, 1-64 Bytes"
    latitude: float
    "Location latitude in degrees"
    longitude: float
    "Location longitude in degrees"
    title: str
    "Location title"
    horizontal_accuracy: float | None = None
    "Optional. The radius of uncertainty for the location, measured in meters; 0-1500"
    live_period: int | None = None
    "Optional. Period in seconds for which the location can be updated, should be between 60 and 86400."
    heading: int | None = None
    "Optional. For live locations, a direction in which the user is moving, in degrees. Must be between 1 and 360 if specified."
    proximity_alert_radius: int | None = None
    "Optional. For live locations, a maximum distance for proximity alerts about approaching another chat member, in meters. Must be between 1 and 100000 if specified."
    reply_markup: InlineKeyboardMarkup | None = None
    "Optional. Inline keyboard attached to the message"
    input_message_content: InputMessageContent | None = None
    "Optional. Content of the message to be sent instead of the location"
    thumbnail_url: str | None = None
    "Optional. Url of the thumbnail for the result"
    thumbnail_width: int | None = None
    "Optional. Thumbnail width"
    thumbnail_height: int | None = None
    "Optional. Thumbnail height"

    def copy_with(
        self,
        type: str | None = None,
        id: str | None = None,
        latitude: float | None = None,
        longitude: float | None = None,
        title: str | None = None,
        horizontal_accuracy: float | None = None,
        live_period: int | None = None,
        heading: int | None = None,
        proximity_alert_radius: int | None = None,
        reply_markup: InlineKeyboardMarkup | None = None,
        input_message_content: InputMessageContent | None = None,
        thumbnail_url: str | None = None,
        thumbnail_width: int | None = None,
        thumbnail_height: int | None = None,
    ) -> InlineQueryResultLocation:
        return InlineQueryResultLocation(
            type=self.type if type is None else type,
            id=self.id if id is None else id,
            latitude=self.latitude if latitude is None else latitude,
            longitude=self.longitude if longitude is None else longitude,
            title=self.title if title is None else title,
            horizontal_accuracy=self.horizontal_accuracy
            if horizontal_accuracy is None
            else horizontal_accuracy,
            live_period=self.live_period if live_period is None else live_period,
            heading=self.heading if heading is None else heading,
            proximity_alert_radius=self.proximity_alert_radius
            if proximity_alert_radius is None
            else proximity_alert_radius,
            reply_markup=self.reply_markup if reply_markup is None else reply_markup,
            input_message_content=self.input_message_content
            if input_message_content is None
            else input_message_content,
            thumbnail_url=self.thumbnail_url
            if thumbnail_url is None
            else thumbnail_url,
            thumbnail_width=self.thumbnail_width
            if thumbnail_width is None
            else thumbnail_width,
            thumbnail_height=self.thumbnail_height
            if thumbnail_height is None
            else thumbnail_height,
        )


@dataclasses.dataclass(slots=True)
class InlineQueryResultVenue:
    """Represents a venue. By default, the venue will be sent by the user. Alternatively, you can use input_message_content to send a message with the specified content instead of the venue.
    Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them.

    More info: https://core.telegram.org/bots/api#inlinequeryresultvenue"""

    type: str
    "Type of the result, must be venue"
    id: str
    "Unique identifier for this result, 1-64 Bytes"
    latitude: float
    "Latitude of the venue location in degrees"
    longitude: float
    "Longitude of the venue location in degrees"
    title: str
    "Title of the venue"
    address: str
    "Address of the venue"
    foursquare_id: str | None = None
    "Optional. Foursquare identifier of the venue if known"
    foursquare_type: str | None = None
    'Optional. Foursquare type of the venue, if known. (For example, "arts_entertainment/default", "arts_entertainment/aquarium" or "food/icecream".)'
    google_place_id: str | None = None
    "Optional. Google Places identifier of the venue"
    google_place_type: str | None = None
    "Optional. Google Places type of the venue. (See supported types.)"
    reply_markup: InlineKeyboardMarkup | None = None
    "Optional. Inline keyboard attached to the message"
    input_message_content: InputMessageContent | None = None
    "Optional. Content of the message to be sent instead of the venue"
    thumbnail_url: str | None = None
    "Optional. Url of the thumbnail for the result"
    thumbnail_width: int | None = None
    "Optional. Thumbnail width"
    thumbnail_height: int | None = None
    "Optional. Thumbnail height"

    def copy_with(
        self,
        type: str | None = None,
        id: str | None = None,
        latitude: float | None = None,
        longitude: float | None = None,
        title: str | None = None,
        address: str | None = None,
        foursquare_id: str | None = None,
        foursquare_type: str | None = None,
        google_place_id: str | None = None,
        google_place_type: str | None = None,
        reply_markup: InlineKeyboardMarkup | None = None,
        input_message_content: InputMessageContent | None = None,
        thumbnail_url: str | None = None,
        thumbnail_width: int | None = None,
        thumbnail_height: int | None = None,
    ) -> InlineQueryResultVenue:
        return InlineQueryResultVenue(
            type=self.type if type is None else type,
            id=self.id if id is None else id,
            latitude=self.latitude if latitude is None else latitude,
            longitude=self.longitude if longitude is None else longitude,
            title=self.title if title is None else title,
            address=self.address if address is None else address,
            foursquare_id=self.foursquare_id
            if foursquare_id is None
            else foursquare_id,
            foursquare_type=self.foursquare_type
            if foursquare_type is None
            else foursquare_type,
            google_place_id=self.google_place_id
            if google_place_id is None
            else google_place_id,
            google_place_type=self.google_place_type
            if google_place_type is None
            else google_place_type,
            reply_markup=self.reply_markup if reply_markup is None else reply_markup,
            input_message_content=self.input_message_content
            if input_message_content is None
            else input_message_content,
            thumbnail_url=self.thumbnail_url
            if thumbnail_url is None
            else thumbnail_url,
            thumbnail_width=self.thumbnail_width
            if thumbnail_width is None
            else thumbnail_width,
            thumbnail_height=self.thumbnail_height
            if thumbnail_height is None
            else thumbnail_height,
        )


@dataclasses.dataclass(slots=True)
class InlineQueryResultContact:
    """Represents a contact with a phone number. By default, this contact will be sent by the user. Alternatively, you can use input_message_content to send a message with the specified content instead of the contact.
    Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them.

    More info: https://core.telegram.org/bots/api#inlinequeryresultcontact"""

    type: str
    "Type of the result, must be contact"
    id: str
    "Unique identifier for this result, 1-64 Bytes"
    phone_number: str
    "Contact's phone number"
    first_name: str
    "Contact's first name"
    last_name: str | None = None
    "Optional. Contact's last name"
    vcard: str | None = None
    "Optional. Additional data about the contact in the form of a vCard, 0-2048 bytes"
    reply_markup: InlineKeyboardMarkup | None = None
    "Optional. Inline keyboard attached to the message"
    input_message_content: InputMessageContent | None = None
    "Optional. Content of the message to be sent instead of the contact"
    thumbnail_url: str | None = None
    "Optional. Url of the thumbnail for the result"
    thumbnail_width: int | None = None
    "Optional. Thumbnail width"
    thumbnail_height: int | None = None
    "Optional. Thumbnail height"

    def copy_with(
        self,
        type: str | None = None,
        id: str | None = None,
        phone_number: str | None = None,
        first_name: str | None = None,
        last_name: str | None = None,
        vcard: str | None = None,
        reply_markup: InlineKeyboardMarkup | None = None,
        input_message_content: InputMessageContent | None = None,
        thumbnail_url: str | None = None,
        thumbnail_width: int | None = None,
        thumbnail_height: int | None = None,
    ) -> InlineQueryResultContact:
        return InlineQueryResultContact(
            type=self.type if type is None else type,
            id=self.id if id is None else id,
            phone_number=self.phone_number if phone_number is None else phone_number,
            first_name=self.first_name if first_name is None else first_name,
            last_name=self.last_name if last_name is None else last_name,
            vcard=self.vcard if vcard is None else vcard,
            reply_markup=self.reply_markup if reply_markup is None else reply_markup,
            input_message_content=self.input_message_content
            if input_message_content is None
            else input_message_content,
            thumbnail_url=self.thumbnail_url
            if thumbnail_url is None
            else thumbnail_url,
            thumbnail_width=self.thumbnail_width
            if thumbnail_width is None
            else thumbnail_width,
            thumbnail_height=self.thumbnail_height
            if thumbnail_height is None
            else thumbnail_height,
        )


@dataclasses.dataclass(slots=True)
class InlineQueryResultGame:
    """Represents a Game.
    Note: This will only work in Telegram versions released after October 1, 2016. Older clients will not display any inline results if a game result is among them.

    More info: https://core.telegram.org/bots/api#inlinequeryresultgame"""

    type: str
    "Type of the result, must be game"
    id: str
    "Unique identifier for this result, 1-64 bytes"
    game_short_name: str
    "Short name of the game"
    reply_markup: InlineKeyboardMarkup | None = None
    "Optional. Inline keyboard attached to the message"

    def copy_with(
        self,
        type: str | None = None,
        id: str | None = None,
        game_short_name: str | None = None,
        reply_markup: InlineKeyboardMarkup | None = None,
    ) -> InlineQueryResultGame:
        return InlineQueryResultGame(
            type=self.type if type is None else type,
            id=self.id if id is None else id,
            game_short_name=self.game_short_name
            if game_short_name is None
            else game_short_name,
            reply_markup=self.reply_markup if reply_markup is None else reply_markup,
        )


@dataclasses.dataclass(slots=True)
class InlineQueryResultCachedPhoto:
    """Represents a link to a photo stored on the Telegram servers. By default, this photo will be sent by the user with an optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the photo.

    More info: https://core.telegram.org/bots/api#inlinequeryresultcachedphoto"""

    type: str
    "Type of the result, must be photo"
    id: str
    "Unique identifier for this result, 1-64 bytes"
    photo_file_id: str
    "A valid file identifier of the photo"
    title: str | None = None
    "Optional. Title for the result"
    description: str | None = None
    "Optional. Short description of the result"
    caption: str | None = None
    "Optional. Caption of the photo to be sent, 0-1024 characters after entities parsing"
    parse_mode: str | None = None
    "Optional. Mode for parsing entities in the photo caption. See formatting options for more details."
    caption_entities: list[MessageEntity] | None = None
    "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"
    reply_markup: InlineKeyboardMarkup | None = None
    "Optional. Inline keyboard attached to the message"
    input_message_content: InputMessageContent | None = None
    "Optional. Content of the message to be sent instead of the photo"

    def copy_with(
        self,
        type: str | None = None,
        id: str | None = None,
        photo_file_id: str | None = None,
        title: str | None = None,
        description: str | None = None,
        caption: str | None = None,
        parse_mode: str | None = None,
        caption_entities: list[MessageEntity] | None = None,
        reply_markup: InlineKeyboardMarkup | None = None,
        input_message_content: InputMessageContent | None = None,
    ) -> InlineQueryResultCachedPhoto:
        return InlineQueryResultCachedPhoto(
            type=self.type if type is None else type,
            id=self.id if id is None else id,
            photo_file_id=self.photo_file_id
            if photo_file_id is None
            else photo_file_id,
            title=self.title if title is None else title,
            description=self.description if description is None else description,
            caption=self.caption if caption is None else caption,
            parse_mode=self.parse_mode if parse_mode is None else parse_mode,
            caption_entities=self.caption_entities
            if caption_entities is None
            else caption_entities,
            reply_markup=self.reply_markup if reply_markup is None else reply_markup,
            input_message_content=self.input_message_content
            if input_message_content is None
            else input_message_content,
        )


@dataclasses.dataclass(slots=True)
class InlineQueryResultCachedGif:
    """Represents a link to an animated GIF file stored on the Telegram servers. By default, this animated GIF file will be sent by the user with an optional caption. Alternatively, you can use input_message_content to send a message with specified content instead of the animation.

    More info: https://core.telegram.org/bots/api#inlinequeryresultcachedgif"""

    type: str
    "Type of the result, must be gif"
    id: str
    "Unique identifier for this result, 1-64 bytes"
    gif_file_id: str
    "A valid file identifier for the GIF file"
    title: str | None = None
    "Optional. Title for the result"
    caption: str | None = None
    "Optional. Caption of the GIF file to be sent, 0-1024 characters after entities parsing"
    parse_mode: str | None = None
    "Optional. Mode for parsing entities in the caption. See formatting options for more details."
    caption_entities: list[MessageEntity] | None = None
    "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"
    reply_markup: InlineKeyboardMarkup | None = None
    "Optional. Inline keyboard attached to the message"
    input_message_content: InputMessageContent | None = None
    "Optional. Content of the message to be sent instead of the GIF animation"

    def copy_with(
        self,
        type: str | None = None,
        id: str | None = None,
        gif_file_id: str | None = None,
        title: str | None = None,
        caption: str | None = None,
        parse_mode: str | None = None,
        caption_entities: list[MessageEntity] | None = None,
        reply_markup: InlineKeyboardMarkup | None = None,
        input_message_content: InputMessageContent | None = None,
    ) -> InlineQueryResultCachedGif:
        return InlineQueryResultCachedGif(
            type=self.type if type is None else type,
            id=self.id if id is None else id,
            gif_file_id=self.gif_file_id if gif_file_id is None else gif_file_id,
            title=self.title if title is None else title,
            caption=self.caption if caption is None else caption,
            parse_mode=self.parse_mode if parse_mode is None else parse_mode,
            caption_entities=self.caption_entities
            if caption_entities is None
            else caption_entities,
            reply_markup=self.reply_markup if reply_markup is None else reply_markup,
            input_message_content=self.input_message_content
            if input_message_content is None
            else input_message_content,
        )


@dataclasses.dataclass(slots=True)
class InlineQueryResultCachedMpeg4Gif:
    """Represents a link to a video animation (H.264/MPEG-4 AVC video without sound) stored on the Telegram servers. By default, this animated MPEG-4 file will be sent by the user with an optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the animation.

    More info: https://core.telegram.org/bots/api#inlinequeryresultcachedmpeg4gif"""

    type: str
    "Type of the result, must be mpeg4_gif"
    id: str
    "Unique identifier for this result, 1-64 bytes"
    mpeg4_file_id: str
    "A valid file identifier for the MPEG4 file"
    title: str | None = None
    "Optional. Title for the result"
    caption: str | None = None
    "Optional. Caption of the MPEG-4 file to be sent, 0-1024 characters after entities parsing"
    parse_mode: str | None = None
    "Optional. Mode for parsing entities in the caption. See formatting options for more details."
    caption_entities: list[MessageEntity] | None = None
    "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"
    reply_markup: InlineKeyboardMarkup | None = None
    "Optional. Inline keyboard attached to the message"
    input_message_content: InputMessageContent | None = None
    "Optional. Content of the message to be sent instead of the video animation"

    def copy_with(
        self,
        type: str | None = None,
        id: str | None = None,
        mpeg4_file_id: str | None = None,
        title: str | None = None,
        caption: str | None = None,
        parse_mode: str | None = None,
        caption_entities: list[MessageEntity] | None = None,
        reply_markup: InlineKeyboardMarkup | None = None,
        input_message_content: InputMessageContent | None = None,
    ) -> InlineQueryResultCachedMpeg4Gif:
        return InlineQueryResultCachedMpeg4Gif(
            type=self.type if type is None else type,
            id=self.id if id is None else id,
            mpeg4_file_id=self.mpeg4_file_id
            if mpeg4_file_id is None
            else mpeg4_file_id,
            title=self.title if title is None else title,
            caption=self.caption if caption is None else caption,
            parse_mode=self.parse_mode if parse_mode is None else parse_mode,
            caption_entities=self.caption_entities
            if caption_entities is None
            else caption_entities,
            reply_markup=self.reply_markup if reply_markup is None else reply_markup,
            input_message_content=self.input_message_content
            if input_message_content is None
            else input_message_content,
        )


@dataclasses.dataclass(slots=True)
class InlineQueryResultCachedSticker:
    """Represents a link to a sticker stored on the Telegram servers. By default, this sticker will be sent by the user. Alternatively, you can use input_message_content to send a message with the specified content instead of the sticker.
    Note: This will only work in Telegram versions released after 9 April, 2016 for static stickers and after 06 July, 2019 for animated stickers. Older clients will ignore them.

    More info: https://core.telegram.org/bots/api#inlinequeryresultcachedsticker"""

    type: str
    "Type of the result, must be sticker"
    id: str
    "Unique identifier for this result, 1-64 bytes"
    sticker_file_id: str
    "A valid file identifier of the sticker"
    reply_markup: InlineKeyboardMarkup | None = None
    "Optional. Inline keyboard attached to the message"
    input_message_content: InputMessageContent | None = None
    "Optional. Content of the message to be sent instead of the sticker"

    def copy_with(
        self,
        type: str | None = None,
        id: str | None = None,
        sticker_file_id: str | None = None,
        reply_markup: InlineKeyboardMarkup | None = None,
        input_message_content: InputMessageContent | None = None,
    ) -> InlineQueryResultCachedSticker:
        return InlineQueryResultCachedSticker(
            type=self.type if type is None else type,
            id=self.id if id is None else id,
            sticker_file_id=self.sticker_file_id
            if sticker_file_id is None
            else sticker_file_id,
            reply_markup=self.reply_markup if reply_markup is None else reply_markup,
            input_message_content=self.input_message_content
            if input_message_content is None
            else input_message_content,
        )


@dataclasses.dataclass(slots=True)
class InlineQueryResultCachedDocument:
    """Represents a link to a file stored on the Telegram servers. By default, this file will be sent by the user with an optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the file.
    Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them.

    More info: https://core.telegram.org/bots/api#inlinequeryresultcacheddocument"""

    type: str
    "Type of the result, must be document"
    id: str
    "Unique identifier for this result, 1-64 bytes"
    title: str
    "Title for the result"
    document_file_id: str
    "A valid file identifier for the file"
    description: str | None = None
    "Optional. Short description of the result"
    caption: str | None = None
    "Optional. Caption of the document to be sent, 0-1024 characters after entities parsing"
    parse_mode: str | None = None
    "Optional. Mode for parsing entities in the document caption. See formatting options for more details."
    caption_entities: list[MessageEntity] | None = None
    "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"
    reply_markup: InlineKeyboardMarkup | None = None
    "Optional. Inline keyboard attached to the message"
    input_message_content: InputMessageContent | None = None
    "Optional. Content of the message to be sent instead of the file"

    def copy_with(
        self,
        type: str | None = None,
        id: str | None = None,
        title: str | None = None,
        document_file_id: str | None = None,
        description: str | None = None,
        caption: str | None = None,
        parse_mode: str | None = None,
        caption_entities: list[MessageEntity] | None = None,
        reply_markup: InlineKeyboardMarkup | None = None,
        input_message_content: InputMessageContent | None = None,
    ) -> InlineQueryResultCachedDocument:
        return InlineQueryResultCachedDocument(
            type=self.type if type is None else type,
            id=self.id if id is None else id,
            title=self.title if title is None else title,
            document_file_id=self.document_file_id
            if document_file_id is None
            else document_file_id,
            description=self.description if description is None else description,
            caption=self.caption if caption is None else caption,
            parse_mode=self.parse_mode if parse_mode is None else parse_mode,
            caption_entities=self.caption_entities
            if caption_entities is None
            else caption_entities,
            reply_markup=self.reply_markup if reply_markup is None else reply_markup,
            input_message_content=self.input_message_content
            if input_message_content is None
            else input_message_content,
        )


@dataclasses.dataclass(slots=True)
class InlineQueryResultCachedVideo:
    """Represents a link to a video file stored on the Telegram servers. By default, this video file will be sent by the user with an optional caption. Alternatively, you can use input_message_content to send a message with the specified content instead of the video.

    More info: https://core.telegram.org/bots/api#inlinequeryresultcachedvideo"""

    type: str
    "Type of the result, must be video"
    id: str
    "Unique identifier for this result, 1-64 bytes"
    video_file_id: str
    "A valid file identifier for the video file"
    title: str
    "Title for the result"
    description: str | None = None
    "Optional. Short description of the result"
    caption: str | None = None
    "Optional. Caption of the video to be sent, 0-1024 characters after entities parsing"
    parse_mode: str | None = None
    "Optional. Mode for parsing entities in the video caption. See formatting options for more details."
    caption_entities: list[MessageEntity] | None = None
    "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"
    reply_markup: InlineKeyboardMarkup | None = None
    "Optional. Inline keyboard attached to the message"
    input_message_content: InputMessageContent | None = None
    "Optional. Content of the message to be sent instead of the video"

    def copy_with(
        self,
        type: str | None = None,
        id: str | None = None,
        video_file_id: str | None = None,
        title: str | None = None,
        description: str | None = None,
        caption: str | None = None,
        parse_mode: str | None = None,
        caption_entities: list[MessageEntity] | None = None,
        reply_markup: InlineKeyboardMarkup | None = None,
        input_message_content: InputMessageContent | None = None,
    ) -> InlineQueryResultCachedVideo:
        return InlineQueryResultCachedVideo(
            type=self.type if type is None else type,
            id=self.id if id is None else id,
            video_file_id=self.video_file_id
            if video_file_id is None
            else video_file_id,
            title=self.title if title is None else title,
            description=self.description if description is None else description,
            caption=self.caption if caption is None else caption,
            parse_mode=self.parse_mode if parse_mode is None else parse_mode,
            caption_entities=self.caption_entities
            if caption_entities is None
            else caption_entities,
            reply_markup=self.reply_markup if reply_markup is None else reply_markup,
            input_message_content=self.input_message_content
            if input_message_content is None
            else input_message_content,
        )


@dataclasses.dataclass(slots=True)
class InlineQueryResultCachedVoice:
    """Represents a link to a voice message stored on the Telegram servers. By default, this voice message will be sent by the user. Alternatively, you can use input_message_content to send a message with the specified content instead of the voice message.
    Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them.

    More info: https://core.telegram.org/bots/api#inlinequeryresultcachedvoice"""

    type: str
    "Type of the result, must be voice"
    id: str
    "Unique identifier for this result, 1-64 bytes"
    voice_file_id: str
    "A valid file identifier for the voice message"
    title: str
    "Voice message title"
    caption: str | None = None
    "Optional. Caption, 0-1024 characters after entities parsing"
    parse_mode: str | None = None
    "Optional. Mode for parsing entities in the voice message caption. See formatting options for more details."
    caption_entities: list[MessageEntity] | None = None
    "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"
    reply_markup: InlineKeyboardMarkup | None = None
    "Optional. Inline keyboard attached to the message"
    input_message_content: InputMessageContent | None = None
    "Optional. Content of the message to be sent instead of the voice message"

    def copy_with(
        self,
        type: str | None = None,
        id: str | None = None,
        voice_file_id: str | None = None,
        title: str | None = None,
        caption: str | None = None,
        parse_mode: str | None = None,
        caption_entities: list[MessageEntity] | None = None,
        reply_markup: InlineKeyboardMarkup | None = None,
        input_message_content: InputMessageContent | None = None,
    ) -> InlineQueryResultCachedVoice:
        return InlineQueryResultCachedVoice(
            type=self.type if type is None else type,
            id=self.id if id is None else id,
            voice_file_id=self.voice_file_id
            if voice_file_id is None
            else voice_file_id,
            title=self.title if title is None else title,
            caption=self.caption if caption is None else caption,
            parse_mode=self.parse_mode if parse_mode is None else parse_mode,
            caption_entities=self.caption_entities
            if caption_entities is None
            else caption_entities,
            reply_markup=self.reply_markup if reply_markup is None else reply_markup,
            input_message_content=self.input_message_content
            if input_message_content is None
            else input_message_content,
        )


@dataclasses.dataclass(slots=True)
class InlineQueryResultCachedAudio:
    """Represents a link to an MP3 audio file stored on the Telegram servers. By default, this audio file will be sent by the user. Alternatively, you can use input_message_content to send a message with the specified content instead of the audio.
    Note: This will only work in Telegram versions released after 9 April, 2016. Older clients will ignore them.

    More info: https://core.telegram.org/bots/api#inlinequeryresultcachedaudio"""

    type: str
    "Type of the result, must be audio"
    id: str
    "Unique identifier for this result, 1-64 bytes"
    audio_file_id: str
    "A valid file identifier for the audio file"
    caption: str | None = None
    "Optional. Caption, 0-1024 characters after entities parsing"
    parse_mode: str | None = None
    "Optional. Mode for parsing entities in the audio caption. See formatting options for more details."
    caption_entities: list[MessageEntity] | None = None
    "Optional. List of special entities that appear in the caption, which can be specified instead of parse_mode"
    reply_markup: InlineKeyboardMarkup | None = None
    "Optional. Inline keyboard attached to the message"
    input_message_content: InputMessageContent | None = None
    "Optional. Content of the message to be sent instead of the audio"

    def copy_with(
        self,
        type: str | None = None,
        id: str | None = None,
        audio_file_id: str | None = None,
        caption: str | None = None,
        parse_mode: str | None = None,
        caption_entities: list[MessageEntity] | None = None,
        reply_markup: InlineKeyboardMarkup | None = None,
        input_message_content: InputMessageContent | None = None,
    ) -> InlineQueryResultCachedAudio:
        return InlineQueryResultCachedAudio(
            type=self.type if type is None else type,
            id=self.id if id is None else id,
            audio_file_id=self.audio_file_id
            if audio_file_id is None
            else audio_file_id,
            caption=self.caption if caption is None else caption,
            parse_mode=self.parse_mode if parse_mode is None else parse_mode,
            caption_entities=self.caption_entities
            if caption_entities is None
            else caption_entities,
            reply_markup=self.reply_markup if reply_markup is None else reply_markup,
            input_message_content=self.input_message_content
            if input_message_content is None
            else input_message_content,
        )


@dataclasses.dataclass(slots=True)
class InputTextMessageContent:
    """Represents the content of a text message to be sent as the result of an inline query.

    More info: https://core.telegram.org/bots/api#inputtextmessagecontent"""

    message_text: str
    "Text of the message to be sent, 1-4096 characters"
    parse_mode: str | None = None
    "Optional. Mode for parsing entities in the message text. See formatting options for more details."
    entities: list[MessageEntity] | None = None
    "Optional. List of special entities that appear in message text, which can be specified instead of parse_mode"
    disable_web_page_preview: bool | None = None
    "Optional. Disables link previews for links in the sent message"

    def copy_with(
        self,
        message_text: str | None = None,
        parse_mode: str | None = None,
        entities: list[MessageEntity] | None = None,
        disable_web_page_preview: bool | None = None,
    ) -> InputTextMessageContent:
        return InputTextMessageContent(
            message_text=self.message_text if message_text is None else message_text,
            parse_mode=self.parse_mode if parse_mode is None else parse_mode,
            entities=self.entities if entities is None else entities,
            disable_web_page_preview=self.disable_web_page_preview
            if disable_web_page_preview is None
            else disable_web_page_preview,
        )


@dataclasses.dataclass(slots=True)
class InputLocationMessageContent:
    """Represents the content of a location message to be sent as the result of an inline query.

    More info: https://core.telegram.org/bots/api#inputlocationmessagecontent"""

    latitude: float
    "Latitude of the location in degrees"
    longitude: float
    "Longitude of the location in degrees"
    horizontal_accuracy: float | None = None
    "Optional. The radius of uncertainty for the location, measured in meters; 0-1500"
    live_period: int | None = None
    "Optional. Period in seconds for which the location can be updated, should be between 60 and 86400."
    heading: int | None = None
    "Optional. For live locations, a direction in which the user is moving, in degrees. Must be between 1 and 360 if specified."
    proximity_alert_radius: int | None = None
    "Optional. For live locations, a maximum distance for proximity alerts about approaching another chat member, in meters. Must be between 1 and 100000 if specified."

    def copy_with(
        self,
        latitude: float | None = None,
        longitude: float | None = None,
        horizontal_accuracy: float | None = None,
        live_period: int | None = None,
        heading: int | None = None,
        proximity_alert_radius: int | None = None,
    ) -> InputLocationMessageContent:
        return InputLocationMessageContent(
            latitude=self.latitude if latitude is None else latitude,
            longitude=self.longitude if longitude is None else longitude,
            horizontal_accuracy=self.horizontal_accuracy
            if horizontal_accuracy is None
            else horizontal_accuracy,
            live_period=self.live_period if live_period is None else live_period,
            heading=self.heading if heading is None else heading,
            proximity_alert_radius=self.proximity_alert_radius
            if proximity_alert_radius is None
            else proximity_alert_radius,
        )


@dataclasses.dataclass(slots=True)
class InputVenueMessageContent:
    """Represents the content of a venue message to be sent as the result of an inline query.

    More info: https://core.telegram.org/bots/api#inputvenuemessagecontent"""

    latitude: float
    "Latitude of the venue in degrees"
    longitude: float
    "Longitude of the venue in degrees"
    title: str
    "Name of the venue"
    address: str
    "Address of the venue"
    foursquare_id: str | None = None
    "Optional. Foursquare identifier of the venue, if known"
    foursquare_type: str | None = None
    'Optional. Foursquare type of the venue, if known. (For example, "arts_entertainment/default", "arts_entertainment/aquarium" or "food/icecream".)'
    google_place_id: str | None = None
    "Optional. Google Places identifier of the venue"
    google_place_type: str | None = None
    "Optional. Google Places type of the venue. (See supported types.)"

    def copy_with(
        self,
        latitude: float | None = None,
        longitude: float | None = None,
        title: str | None = None,
        address: str | None = None,
        foursquare_id: str | None = None,
        foursquare_type: str | None = None,
        google_place_id: str | None = None,
        google_place_type: str | None = None,
    ) -> InputVenueMessageContent:
        return InputVenueMessageContent(
            latitude=self.latitude if latitude is None else latitude,
            longitude=self.longitude if longitude is None else longitude,
            title=self.title if title is None else title,
            address=self.address if address is None else address,
            foursquare_id=self.foursquare_id
            if foursquare_id is None
            else foursquare_id,
            foursquare_type=self.foursquare_type
            if foursquare_type is None
            else foursquare_type,
            google_place_id=self.google_place_id
            if google_place_id is None
            else google_place_id,
            google_place_type=self.google_place_type
            if google_place_type is None
            else google_place_type,
        )


@dataclasses.dataclass(slots=True)
class InputContactMessageContent:
    """Represents the content of a contact message to be sent as the result of an inline query.

    More info: https://core.telegram.org/bots/api#inputcontactmessagecontent"""

    phone_number: str
    "Contact's phone number"
    first_name: str
    "Contact's first name"
    last_name: str | None = None
    "Optional. Contact's last name"
    vcard: str | None = None
    "Optional. Additional data about the contact in the form of a vCard, 0-2048 bytes"

    def copy_with(
        self,
        phone_number: str | None = None,
        first_name: str | None = None,
        last_name: str | None = None,
        vcard: str | None = None,
    ) -> InputContactMessageContent:
        return InputContactMessageContent(
            phone_number=self.phone_number if phone_number is None else phone_number,
            first_name=self.first_name if first_name is None else first_name,
            last_name=self.last_name if last_name is None else last_name,
            vcard=self.vcard if vcard is None else vcard,
        )


@dataclasses.dataclass(slots=True)
class InputInvoiceMessageContent:
    """Represents the content of an invoice message to be sent as the result of an inline query.

    More info: https://core.telegram.org/bots/api#inputinvoicemessagecontent"""

    title: str
    "Product name, 1-32 characters"
    description: str
    "Product description, 1-255 characters"
    payload: str
    "Bot-defined invoice payload, 1-128 bytes. This will not be displayed to the user, use for your internal processes."
    provider_token: str
    "Payment provider token, obtained via @BotFather"
    currency: str
    "Three-letter ISO 4217 currency code, see more on currencies"
    prices: list[LabeledPrice]
    "Price breakdown, a JSON-serialized list of components (e.g. product price, tax, discount, delivery cost, delivery tax, bonus, etc.)"
    max_tip_amount: int | None = None
    "Optional. The maximum accepted amount for tips in the smallest units of the currency (integer, not float/double). For example, for a maximum tip of US$ 1.45 pass max_tip_amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies). Defaults to 0"
    suggested_tip_amounts: list[int] | None = None
    "Optional. A JSON-serialized array of suggested amounts of tip in the smallest units of the currency (integer, not float/double). At most 4 suggested tip amounts can be specified. The suggested tip amounts must be positive, passed in a strictly increased order and must not exceed max_tip_amount."
    provider_data: str | None = None
    "Optional. A JSON-serialized object for data about the invoice, which will be shared with the payment provider. A detailed description of the required fields should be provided by the payment provider."
    photo_url: str | None = None
    "Optional. URL of the product photo for the invoice. Can be a photo of the goods or a marketing image for a service."
    photo_size: int | None = None
    "Optional. Photo size in bytes"
    photo_width: int | None = None
    "Optional. Photo width"
    photo_height: int | None = None
    "Optional. Photo height"
    need_name: bool | None = None
    "Optional. Pass True if you require the user's full name to complete the order"
    need_phone_number: bool | None = None
    "Optional. Pass True if you require the user's phone number to complete the order"
    need_email: bool | None = None
    "Optional. Pass True if you require the user's email address to complete the order"
    need_shipping_address: bool | None = None
    "Optional. Pass True if you require the user's shipping address to complete the order"
    send_phone_number_to_provider: bool | None = None
    "Optional. Pass True if the user's phone number should be sent to provider"
    send_email_to_provider: bool | None = None
    "Optional. Pass True if the user's email address should be sent to provider"
    is_flexible: bool | None = None
    "Optional. Pass True if the final price depends on the shipping method"

    def copy_with(
        self,
        title: str | None = None,
        description: str | None = None,
        payload: str | None = None,
        provider_token: str | None = None,
        currency: str | None = None,
        prices: list[LabeledPrice] | None = None,
        max_tip_amount: int | None = None,
        suggested_tip_amounts: list[int] | None = None,
        provider_data: str | None = None,
        photo_url: str | None = None,
        photo_size: int | None = None,
        photo_width: int | None = None,
        photo_height: int | None = None,
        need_name: bool | None = None,
        need_phone_number: bool | None = None,
        need_email: bool | None = None,
        need_shipping_address: bool | None = None,
        send_phone_number_to_provider: bool | None = None,
        send_email_to_provider: bool | None = None,
        is_flexible: bool | None = None,
    ) -> InputInvoiceMessageContent:
        return InputInvoiceMessageContent(
            title=self.title if title is None else title,
            description=self.description if description is None else description,
            payload=self.payload if payload is None else payload,
            provider_token=self.provider_token
            if provider_token is None
            else provider_token,
            currency=self.currency if currency is None else currency,
            prices=self.prices if prices is None else prices,
            max_tip_amount=self.max_tip_amount
            if max_tip_amount is None
            else max_tip_amount,
            suggested_tip_amounts=self.suggested_tip_amounts
            if suggested_tip_amounts is None
            else suggested_tip_amounts,
            provider_data=self.provider_data
            if provider_data is None
            else provider_data,
            photo_url=self.photo_url if photo_url is None else photo_url,
            photo_size=self.photo_size if photo_size is None else photo_size,
            photo_width=self.photo_width if photo_width is None else photo_width,
            photo_height=self.photo_height if photo_height is None else photo_height,
            need_name=self.need_name if need_name is None else need_name,
            need_phone_number=self.need_phone_number
            if need_phone_number is None
            else need_phone_number,
            need_email=self.need_email if need_email is None else need_email,
            need_shipping_address=self.need_shipping_address
            if need_shipping_address is None
            else need_shipping_address,
            send_phone_number_to_provider=self.send_phone_number_to_provider
            if send_phone_number_to_provider is None
            else send_phone_number_to_provider,
            send_email_to_provider=self.send_email_to_provider
            if send_email_to_provider is None
            else send_email_to_provider,
            is_flexible=self.is_flexible if is_flexible is None else is_flexible,
        )


@dataclasses.dataclass(slots=True)
class ChosenInlineResult:
    """Represents a result of an inline query that was chosen by the user and sent to their chat partner.
    Note: It is necessary to enable inline feedback via @BotFather in order to receive these objects in updates.

    More info: https://core.telegram.org/bots/api#choseninlineresult"""

    result_id: str
    "The unique identifier for the result that was chosen"
    from_: User
    "The user that chose the result"
    query: str
    "The query that was used to obtain the result"
    location: Location | None = None
    "Optional. Sender location, only for bots that require user location"
    inline_message_id: str | None = None
    "Optional. Identifier of the sent inline message. Available only if there is an inline keyboard attached to the message. Will be also received in callback queries and can be used to edit the message."

    def copy_with(
        self,
        result_id: str | None = None,
        from_: User | None = None,
        location: Location | None = None,
        inline_message_id: str | None = None,
        query: str | None = None,
    ) -> ChosenInlineResult:
        return ChosenInlineResult(
            result_id=self.result_id if result_id is None else result_id,
            from_=self.from_ if from_ is None else from_,
            location=self.location if location is None else location,
            inline_message_id=self.inline_message_id
            if inline_message_id is None
            else inline_message_id,
            query=self.query if query is None else query,
        )


@dataclasses.dataclass(slots=True)
class SentWebAppMessage:
    """Describes an inline message sent by a Web App on behalf of a user.

    More info: https://core.telegram.org/bots/api#sentwebappmessage"""

    inline_message_id: str | None = None
    "Optional. Identifier of the sent inline message. Available only if there is an inline keyboard attached to the message."

    def copy_with(
        self,
        inline_message_id: str | None = None,
    ) -> SentWebAppMessage:
        return SentWebAppMessage(
            inline_message_id=self.inline_message_id
            if inline_message_id is None
            else inline_message_id
        )


@dataclasses.dataclass(slots=True)
class LabeledPrice:
    """This object represents a portion of the price for goods or services.

    More info: https://core.telegram.org/bots/api#labeledprice"""

    label: str
    "Portion label"
    amount: int
    "Price of the product in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."

    def copy_with(
        self,
        label: str | None = None,
        amount: int | None = None,
    ) -> LabeledPrice:
        return LabeledPrice(
            label=self.label if label is None else label,
            amount=self.amount if amount is None else amount,
        )


@dataclasses.dataclass(slots=True)
class Invoice:
    """This object contains basic information about an invoice.

    More info: https://core.telegram.org/bots/api#invoice"""

    title: str
    "Product name"
    description: str
    "Product description"
    start_parameter: str
    "Unique bot deep-linking parameter that can be used to generate this invoice"
    currency: str
    "Three-letter ISO 4217 currency code"
    total_amount: int
    "Total price in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."

    def copy_with(
        self,
        title: str | None = None,
        description: str | None = None,
        start_parameter: str | None = None,
        currency: str | None = None,
        total_amount: int | None = None,
    ) -> Invoice:
        return Invoice(
            title=self.title if title is None else title,
            description=self.description if description is None else description,
            start_parameter=self.start_parameter
            if start_parameter is None
            else start_parameter,
            currency=self.currency if currency is None else currency,
            total_amount=self.total_amount if total_amount is None else total_amount,
        )


@dataclasses.dataclass(slots=True)
class ShippingAddress:
    """This object represents a shipping address.

    More info: https://core.telegram.org/bots/api#shippingaddress"""

    country_code: str
    "Two-letter ISO 3166-1 alpha-2 country code"
    state: str
    "State, if applicable"
    city: str
    "City"
    street_line1: str
    "First line for the address"
    street_line2: str
    "Second line for the address"
    post_code: str
    "Address post code"

    def copy_with(
        self,
        country_code: str | None = None,
        state: str | None = None,
        city: str | None = None,
        street_line1: str | None = None,
        street_line2: str | None = None,
        post_code: str | None = None,
    ) -> ShippingAddress:
        return ShippingAddress(
            country_code=self.country_code if country_code is None else country_code,
            state=self.state if state is None else state,
            city=self.city if city is None else city,
            street_line1=self.street_line1 if street_line1 is None else street_line1,
            street_line2=self.street_line2 if street_line2 is None else street_line2,
            post_code=self.post_code if post_code is None else post_code,
        )


@dataclasses.dataclass(slots=True)
class OrderInfo:
    """This object represents information about an order.

    More info: https://core.telegram.org/bots/api#orderinfo"""

    name: str | None = None
    "Optional. User name"
    phone_number: str | None = None
    "Optional. User's phone number"
    email: str | None = None
    "Optional. User email"
    shipping_address: ShippingAddress | None = None
    "Optional. User shipping address"

    def copy_with(
        self,
        name: str | None = None,
        phone_number: str | None = None,
        email: str | None = None,
        shipping_address: ShippingAddress | None = None,
    ) -> OrderInfo:
        return OrderInfo(
            name=self.name if name is None else name,
            phone_number=self.phone_number if phone_number is None else phone_number,
            email=self.email if email is None else email,
            shipping_address=self.shipping_address
            if shipping_address is None
            else shipping_address,
        )


@dataclasses.dataclass(slots=True)
class ShippingOption:
    """This object represents one shipping option.

    More info: https://core.telegram.org/bots/api#shippingoption"""

    id: str
    "Shipping option identifier"
    title: str
    "Option title"
    prices: list[LabeledPrice]
    "List of price portions"

    def copy_with(
        self,
        id: str | None = None,
        title: str | None = None,
        prices: list[LabeledPrice] | None = None,
    ) -> ShippingOption:
        return ShippingOption(
            id=self.id if id is None else id,
            title=self.title if title is None else title,
            prices=self.prices if prices is None else prices,
        )


@dataclasses.dataclass(slots=True)
class SuccessfulPayment:
    """This object contains basic information about a successful payment.

    More info: https://core.telegram.org/bots/api#successfulpayment"""

    currency: str
    "Three-letter ISO 4217 currency code"
    total_amount: int
    "Total price in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."
    invoice_payload: str
    "Bot specified invoice payload"
    telegram_payment_charge_id: str
    "Telegram payment identifier"
    provider_payment_charge_id: str
    "Provider payment identifier"
    shipping_option_id: str | None = None
    "Optional. Identifier of the shipping option chosen by the user"
    order_info: OrderInfo | None = None
    "Optional. Order information provided by the user"

    def copy_with(
        self,
        currency: str | None = None,
        total_amount: int | None = None,
        invoice_payload: str | None = None,
        shipping_option_id: str | None = None,
        order_info: OrderInfo | None = None,
        telegram_payment_charge_id: str | None = None,
        provider_payment_charge_id: str | None = None,
    ) -> SuccessfulPayment:
        return SuccessfulPayment(
            currency=self.currency if currency is None else currency,
            total_amount=self.total_amount if total_amount is None else total_amount,
            invoice_payload=self.invoice_payload
            if invoice_payload is None
            else invoice_payload,
            shipping_option_id=self.shipping_option_id
            if shipping_option_id is None
            else shipping_option_id,
            order_info=self.order_info if order_info is None else order_info,
            telegram_payment_charge_id=self.telegram_payment_charge_id
            if telegram_payment_charge_id is None
            else telegram_payment_charge_id,
            provider_payment_charge_id=self.provider_payment_charge_id
            if provider_payment_charge_id is None
            else provider_payment_charge_id,
        )


@dataclasses.dataclass(slots=True)
class ShippingQuery:
    """This object contains information about an incoming shipping query.

    More info: https://core.telegram.org/bots/api#shippingquery"""

    id: str
    "Unique query identifier"
    from_: User
    "User who sent the query"
    invoice_payload: str
    "Bot specified invoice payload"
    shipping_address: ShippingAddress
    "User specified shipping address"

    def copy_with(
        self,
        id: str | None = None,
        from_: User | None = None,
        invoice_payload: str | None = None,
        shipping_address: ShippingAddress | None = None,
    ) -> ShippingQuery:
        return ShippingQuery(
            id=self.id if id is None else id,
            from_=self.from_ if from_ is None else from_,
            invoice_payload=self.invoice_payload
            if invoice_payload is None
            else invoice_payload,
            shipping_address=self.shipping_address
            if shipping_address is None
            else shipping_address,
        )


@dataclasses.dataclass(slots=True)
class PreCheckoutQuery:
    """This object contains information about an incoming pre-checkout query.

    More info: https://core.telegram.org/bots/api#precheckoutquery"""

    id: str
    "Unique query identifier"
    from_: User
    "User who sent the query"
    currency: str
    "Three-letter ISO 4217 currency code"
    total_amount: int
    "Total price in the smallest units of the currency (integer, not float/double). For example, for a price of US$ 1.45 pass amount = 145. See the exp parameter in currencies.json, it shows the number of digits past the decimal point for each currency (2 for the majority of currencies)."
    invoice_payload: str
    "Bot specified invoice payload"
    shipping_option_id: str | None = None
    "Optional. Identifier of the shipping option chosen by the user"
    order_info: OrderInfo | None = None
    "Optional. Order information provided by the user"

    def copy_with(
        self,
        id: str | None = None,
        from_: User | None = None,
        currency: str | None = None,
        total_amount: int | None = None,
        invoice_payload: str | None = None,
        shipping_option_id: str | None = None,
        order_info: OrderInfo | None = None,
    ) -> PreCheckoutQuery:
        return PreCheckoutQuery(
            id=self.id if id is None else id,
            from_=self.from_ if from_ is None else from_,
            currency=self.currency if currency is None else currency,
            total_amount=self.total_amount if total_amount is None else total_amount,
            invoice_payload=self.invoice_payload
            if invoice_payload is None
            else invoice_payload,
            shipping_option_id=self.shipping_option_id
            if shipping_option_id is None
            else shipping_option_id,
            order_info=self.order_info if order_info is None else order_info,
        )


@dataclasses.dataclass(slots=True)
class PassportData:
    """Describes Telegram Passport data shared with the bot by the user.

    More info: https://core.telegram.org/bots/api#passportdata"""

    data: list[EncryptedPassportElement]
    "Array with information about documents and other Telegram Passport elements that was shared with the bot"
    credentials: EncryptedCredentials
    "Encrypted credentials required to decrypt the data"

    def copy_with(
        self,
        data: list[EncryptedPassportElement] | None = None,
        credentials: EncryptedCredentials | None = None,
    ) -> PassportData:
        return PassportData(
            data=self.data if data is None else data,
            credentials=self.credentials if credentials is None else credentials,
        )


@dataclasses.dataclass(slots=True)
class PassportFile:
    """This object represents a file uploaded to Telegram Passport. Currently all Telegram Passport files are in JPEG format when decrypted and don't exceed 10MB.

    More info: https://core.telegram.org/bots/api#passportfile"""

    file_id: str
    "Identifier for this file, which can be used to download or reuse the file"
    file_unique_id: str
    "Unique identifier for this file, which is supposed to be the same over time and for different bots. Can't be used to download or reuse the file."
    file_size: int
    "File size in bytes"
    file_date: int
    "Unix time when the file was uploaded"

    def copy_with(
        self,
        file_id: str | None = None,
        file_unique_id: str | None = None,
        file_size: int | None = None,
        file_date: int | None = None,
    ) -> PassportFile:
        return PassportFile(
            file_id=self.file_id if file_id is None else file_id,
            file_unique_id=self.file_unique_id
            if file_unique_id is None
            else file_unique_id,
            file_size=self.file_size if file_size is None else file_size,
            file_date=self.file_date if file_date is None else file_date,
        )


@dataclasses.dataclass(slots=True)
class EncryptedPassportElement:
    """Describes documents or other Telegram Passport elements shared with the bot by the user.

    More info: https://core.telegram.org/bots/api#encryptedpassportelement"""

    type: str
    'Element type. One of "personal_details", "passport", "driver_license", "identity_card", "internal_passport", "address", "utility_bill", "bank_statement", "rental_agreement", "passport_registration", "temporary_registration", "phone_number", "email".'
    hash: str
    "Base64-encoded element hash for using in PassportElementErrorUnspecified"
    data: str | None = None
    'Optional. Base64-encoded encrypted Telegram Passport element data provided by the user, available for "personal_details", "passport", "driver_license", "identity_card", "internal_passport" and "address" types. Can be decrypted and verified using the accompanying EncryptedCredentials.'
    phone_number: str | None = None
    'Optional. User\'s verified phone number, available only for "phone_number" type'
    email: str | None = None
    'Optional. User\'s verified email address, available only for "email" type'
    files: list[PassportFile] | None = None
    'Optional. Array of encrypted files with documents provided by the user, available for "utility_bill", "bank_statement", "rental_agreement", "passport_registration" and "temporary_registration" types. Files can be decrypted and verified using the accompanying EncryptedCredentials.'
    front_side: PassportFile | None = None
    'Optional. Encrypted file with the front side of the document, provided by the user. Available for "passport", "driver_license", "identity_card" and "internal_passport". The file can be decrypted and verified using the accompanying EncryptedCredentials.'
    reverse_side: PassportFile | None = None
    'Optional. Encrypted file with the reverse side of the document, provided by the user. Available for "driver_license" and "identity_card". The file can be decrypted and verified using the accompanying EncryptedCredentials.'
    selfie: PassportFile | None = None
    'Optional. Encrypted file with the selfie of the user holding a document, provided by the user; available for "passport", "driver_license", "identity_card" and "internal_passport". The file can be decrypted and verified using the accompanying EncryptedCredentials.'
    translation: list[PassportFile] | None = None
    'Optional. Array of encrypted files with translated versions of documents provided by the user. Available if requested for "passport", "driver_license", "identity_card", "internal_passport", "utility_bill", "bank_statement", "rental_agreement", "passport_registration" and "temporary_registration" types. Files can be decrypted and verified using the accompanying EncryptedCredentials.'

    def copy_with(
        self,
        type: str | None = None,
        data: str | None = None,
        phone_number: str | None = None,
        email: str | None = None,
        files: list[PassportFile] | None = None,
        front_side: PassportFile | None = None,
        reverse_side: PassportFile | None = None,
        selfie: PassportFile | None = None,
        translation: list[PassportFile] | None = None,
        hash: str | None = None,
    ) -> EncryptedPassportElement:
        return EncryptedPassportElement(
            type=self.type if type is None else type,
            data=self.data if data is None else data,
            phone_number=self.phone_number if phone_number is None else phone_number,
            email=self.email if email is None else email,
            files=self.files if files is None else files,
            front_side=self.front_side if front_side is None else front_side,
            reverse_side=self.reverse_side if reverse_side is None else reverse_side,
            selfie=self.selfie if selfie is None else selfie,
            translation=self.translation if translation is None else translation,
            hash=self.hash if hash is None else hash,
        )


@dataclasses.dataclass(slots=True)
class EncryptedCredentials:
    """Describes data required for decrypting and authenticating EncryptedPassportElement. See the Telegram Passport Documentation for a complete description of the data decryption and authentication processes.

    More info: https://core.telegram.org/bots/api#encryptedcredentials"""

    data: str
    "Base64-encoded encrypted JSON-serialized data with unique user's payload, data hashes and secrets required for EncryptedPassportElement decryption and authentication"
    hash: str
    "Base64-encoded data hash for data authentication"
    secret: str
    "Base64-encoded secret, encrypted with the bot's public RSA key, required for data decryption"

    def copy_with(
        self,
        data: str | None = None,
        hash: str | None = None,
        secret: str | None = None,
    ) -> EncryptedCredentials:
        return EncryptedCredentials(
            data=self.data if data is None else data,
            hash=self.hash if hash is None else hash,
            secret=self.secret if secret is None else secret,
        )


@dataclasses.dataclass(slots=True)
class PassportElementErrorDataField:
    """Represents an issue in one of the data fields that was provided by the user. The error is considered resolved when the field's value changes.

    More info: https://core.telegram.org/bots/api#passportelementerrordatafield"""

    source: str
    "Error source, must be data"
    type: str
    'The section of the user\'s Telegram Passport which has the error, one of "personal_details", "passport", "driver_license", "identity_card", "internal_passport", "address"'
    field_name: str
    "Name of the data field which has the error"
    data_hash: str
    "Base64-encoded data hash"
    message: str
    "Error message"

    def copy_with(
        self,
        source: str | None = None,
        type: str | None = None,
        field_name: str | None = None,
        data_hash: str | None = None,
        message: str | None = None,
    ) -> PassportElementErrorDataField:
        return PassportElementErrorDataField(
            source=self.source if source is None else source,
            type=self.type if type is None else type,
            field_name=self.field_name if field_name is None else field_name,
            data_hash=self.data_hash if data_hash is None else data_hash,
            message=self.message if message is None else message,
        )


@dataclasses.dataclass(slots=True)
class PassportElementErrorFrontSide:
    """Represents an issue with the front side of a document. The error is considered resolved when the file with the front side of the document changes.

    More info: https://core.telegram.org/bots/api#passportelementerrorfrontside"""

    source: str
    "Error source, must be front_side"
    type: str
    'The section of the user\'s Telegram Passport which has the issue, one of "passport", "driver_license", "identity_card", "internal_passport"'
    file_hash: str
    "Base64-encoded hash of the file with the front side of the document"
    message: str
    "Error message"

    def copy_with(
        self,
        source: str | None = None,
        type: str | None = None,
        file_hash: str | None = None,
        message: str | None = None,
    ) -> PassportElementErrorFrontSide:
        return PassportElementErrorFrontSide(
            source=self.source if source is None else source,
            type=self.type if type is None else type,
            file_hash=self.file_hash if file_hash is None else file_hash,
            message=self.message if message is None else message,
        )


@dataclasses.dataclass(slots=True)
class PassportElementErrorReverseSide:
    """Represents an issue with the reverse side of a document. The error is considered resolved when the file with reverse side of the document changes.

    More info: https://core.telegram.org/bots/api#passportelementerrorreverseside"""

    source: str
    "Error source, must be reverse_side"
    type: str
    'The section of the user\'s Telegram Passport which has the issue, one of "driver_license", "identity_card"'
    file_hash: str
    "Base64-encoded hash of the file with the reverse side of the document"
    message: str
    "Error message"

    def copy_with(
        self,
        source: str | None = None,
        type: str | None = None,
        file_hash: str | None = None,
        message: str | None = None,
    ) -> PassportElementErrorReverseSide:
        return PassportElementErrorReverseSide(
            source=self.source if source is None else source,
            type=self.type if type is None else type,
            file_hash=self.file_hash if file_hash is None else file_hash,
            message=self.message if message is None else message,
        )


@dataclasses.dataclass(slots=True)
class PassportElementErrorSelfie:
    """Represents an issue with the selfie with a document. The error is considered resolved when the file with the selfie changes.

    More info: https://core.telegram.org/bots/api#passportelementerrorselfie"""

    source: str
    "Error source, must be selfie"
    type: str
    'The section of the user\'s Telegram Passport which has the issue, one of "passport", "driver_license", "identity_card", "internal_passport"'
    file_hash: str
    "Base64-encoded hash of the file with the selfie"
    message: str
    "Error message"

    def copy_with(
        self,
        source: str | None = None,
        type: str | None = None,
        file_hash: str | None = None,
        message: str | None = None,
    ) -> PassportElementErrorSelfie:
        return PassportElementErrorSelfie(
            source=self.source if source is None else source,
            type=self.type if type is None else type,
            file_hash=self.file_hash if file_hash is None else file_hash,
            message=self.message if message is None else message,
        )


@dataclasses.dataclass(slots=True)
class PassportElementErrorFile:
    """Represents an issue with a document scan. The error is considered resolved when the file with the document scan changes.

    More info: https://core.telegram.org/bots/api#passportelementerrorfile"""

    source: str
    "Error source, must be file"
    type: str
    'The section of the user\'s Telegram Passport which has the issue, one of "utility_bill", "bank_statement", "rental_agreement", "passport_registration", "temporary_registration"'
    file_hash: str
    "Base64-encoded file hash"
    message: str
    "Error message"

    def copy_with(
        self,
        source: str | None = None,
        type: str | None = None,
        file_hash: str | None = None,
        message: str | None = None,
    ) -> PassportElementErrorFile:
        return PassportElementErrorFile(
            source=self.source if source is None else source,
            type=self.type if type is None else type,
            file_hash=self.file_hash if file_hash is None else file_hash,
            message=self.message if message is None else message,
        )


@dataclasses.dataclass(slots=True)
class PassportElementErrorFiles:
    """Represents an issue with a list of scans. The error is considered resolved when the list of files containing the scans changes.

    More info: https://core.telegram.org/bots/api#passportelementerrorfiles"""

    source: str
    "Error source, must be files"
    type: str
    'The section of the user\'s Telegram Passport which has the issue, one of "utility_bill", "bank_statement", "rental_agreement", "passport_registration", "temporary_registration"'
    file_hashes: list[str]
    "List of base64-encoded file hashes"
    message: str
    "Error message"

    def copy_with(
        self,
        source: str | None = None,
        type: str | None = None,
        file_hashes: list[str] | None = None,
        message: str | None = None,
    ) -> PassportElementErrorFiles:
        return PassportElementErrorFiles(
            source=self.source if source is None else source,
            type=self.type if type is None else type,
            file_hashes=self.file_hashes if file_hashes is None else file_hashes,
            message=self.message if message is None else message,
        )


@dataclasses.dataclass(slots=True)
class PassportElementErrorTranslationFile:
    """Represents an issue with one of the files that constitute the translation of a document. The error is considered resolved when the file changes.

    More info: https://core.telegram.org/bots/api#passportelementerrortranslationfile"""

    source: str
    "Error source, must be translation_file"
    type: str
    'Type of element of the user\'s Telegram Passport which has the issue, one of "passport", "driver_license", "identity_card", "internal_passport", "utility_bill", "bank_statement", "rental_agreement", "passport_registration", "temporary_registration"'
    file_hash: str
    "Base64-encoded file hash"
    message: str
    "Error message"

    def copy_with(
        self,
        source: str | None = None,
        type: str | None = None,
        file_hash: str | None = None,
        message: str | None = None,
    ) -> PassportElementErrorTranslationFile:
        return PassportElementErrorTranslationFile(
            source=self.source if source is None else source,
            type=self.type if type is None else type,
            file_hash=self.file_hash if file_hash is None else file_hash,
            message=self.message if message is None else message,
        )


@dataclasses.dataclass(slots=True)
class PassportElementErrorTranslationFiles:
    """Represents an issue with the translated version of a document. The error is considered resolved when a file with the document translation change.

    More info: https://core.telegram.org/bots/api#passportelementerrortranslationfiles
    """

    source: str
    "Error source, must be translation_files"
    type: str
    'Type of element of the user\'s Telegram Passport which has the issue, one of "passport", "driver_license", "identity_card", "internal_passport", "utility_bill", "bank_statement", "rental_agreement", "passport_registration", "temporary_registration"'
    file_hashes: list[str]
    "List of base64-encoded file hashes"
    message: str
    "Error message"

    def copy_with(
        self,
        source: str | None = None,
        type: str | None = None,
        file_hashes: list[str] | None = None,
        message: str | None = None,
    ) -> PassportElementErrorTranslationFiles:
        return PassportElementErrorTranslationFiles(
            source=self.source if source is None else source,
            type=self.type if type is None else type,
            file_hashes=self.file_hashes if file_hashes is None else file_hashes,
            message=self.message if message is None else message,
        )


@dataclasses.dataclass(slots=True)
class PassportElementErrorUnspecified:
    """Represents an issue in an unspecified place. The error is considered resolved when new data is added.

    More info: https://core.telegram.org/bots/api#passportelementerrorunspecified"""

    source: str
    "Error source, must be unspecified"
    type: str
    "Type of element of the user's Telegram Passport which has the issue"
    element_hash: str
    "Base64-encoded element hash"
    message: str
    "Error message"

    def copy_with(
        self,
        source: str | None = None,
        type: str | None = None,
        element_hash: str | None = None,
        message: str | None = None,
    ) -> PassportElementErrorUnspecified:
        return PassportElementErrorUnspecified(
            source=self.source if source is None else source,
            type=self.type if type is None else type,
            element_hash=self.element_hash if element_hash is None else element_hash,
            message=self.message if message is None else message,
        )


@dataclasses.dataclass(slots=True)
class Game:
    """This object represents a game. Use BotFather to create and edit games, their short names will act as unique identifiers.

    More info: https://core.telegram.org/bots/api#game"""

    title: str
    "Title of the game"
    description: str
    "Description of the game"
    photo: list[PhotoSize]
    "Photo that will be displayed in the game message in chats."
    text: str | None = None
    "Optional. Brief description of the game or high scores included in the game message. Can be automatically edited to include current high scores for the game when the bot calls setGameScore, or manually edited using editMessageText. 0-4096 characters."
    text_entities: list[MessageEntity] | None = None
    "Optional. Special entities that appear in text, such as usernames, URLs, bot commands, etc."
    animation: Animation | None = None
    "Optional. Animation that will be displayed in the game message in chats. Upload via BotFather"

    def copy_with(
        self,
        title: str | None = None,
        description: str | None = None,
        photo: list[PhotoSize] | None = None,
        text: str | None = None,
        text_entities: list[MessageEntity] | None = None,
        animation: Animation | None = None,
    ) -> Game:
        return Game(
            title=self.title if title is None else title,
            description=self.description if description is None else description,
            photo=self.photo if photo is None else photo,
            text=self.text if text is None else text,
            text_entities=self.text_entities
            if text_entities is None
            else text_entities,
            animation=self.animation if animation is None else animation,
        )


@dataclasses.dataclass(slots=True)
class CallbackGame:
    """A placeholder, currently holds no information. Use BotFather to set up your game.

    More info: https://core.telegram.org/bots/api#callbackgame"""

    pass


@dataclasses.dataclass(slots=True)
class GameHighScore:
    """This object represents one row of the high scores table for a game.

    More info: https://core.telegram.org/bots/api#gamehighscore"""

    position: int
    "Position in high score table for the game"
    user: User
    "User"
    score: int
    "Score"

    def copy_with(
        self,
        position: int | None = None,
        user: User | None = None,
        score: int | None = None,
    ) -> GameHighScore:
        return GameHighScore(
            position=self.position if position is None else position,
            user=self.user if user is None else user,
            score=self.score if score is None else score,
        )


ChatMember: typing.TypeAlias = (
    ChatMemberOwner
    | ChatMemberAdministrator
    | ChatMemberMember
    | ChatMemberRestricted
    | ChatMemberLeft
    | ChatMemberBanned
)
BotCommandScope: typing.TypeAlias = (
    BotCommandScopeDefault
    | BotCommandScopeAllPrivateChats
    | BotCommandScopeAllGroupChats
    | BotCommandScopeAllChatAdministrators
    | BotCommandScopeChat
    | BotCommandScopeChatAdministrators
    | BotCommandScopeChatMember
)
MenuButton: typing.TypeAlias = MenuButtonCommands | MenuButtonWebApp | MenuButtonDefault
InputMedia: typing.TypeAlias = (
    InputMediaAnimation
    | InputMediaDocument
    | InputMediaAudio
    | InputMediaPhoto
    | InputMediaVideo
)
InlineQueryResult: typing.TypeAlias = (
    InlineQueryResultCachedAudio
    | InlineQueryResultCachedDocument
    | InlineQueryResultCachedGif
    | InlineQueryResultCachedMpeg4Gif
    | InlineQueryResultCachedPhoto
    | InlineQueryResultCachedSticker
    | InlineQueryResultCachedVideo
    | InlineQueryResultCachedVoice
    | InlineQueryResultArticle
    | InlineQueryResultAudio
    | InlineQueryResultContact
    | InlineQueryResultGame
    | InlineQueryResultDocument
    | InlineQueryResultGif
    | InlineQueryResultLocation
    | InlineQueryResultMpeg4Gif
    | InlineQueryResultPhoto
    | InlineQueryResultVenue
    | InlineQueryResultVideo
    | InlineQueryResultVoice
)
InputMessageContent: typing.TypeAlias = (
    InputTextMessageContent
    | InputLocationMessageContent
    | InputVenueMessageContent
    | InputContactMessageContent
    | InputInvoiceMessageContent
)
PassportElementError: typing.TypeAlias = (
    PassportElementErrorDataField
    | PassportElementErrorFrontSide
    | PassportElementErrorReverseSide
    | PassportElementErrorSelfie
    | PassportElementErrorFile
    | PassportElementErrorFiles
    | PassportElementErrorTranslationFile
    | PassportElementErrorTranslationFiles
    | PassportElementErrorUnspecified
)
